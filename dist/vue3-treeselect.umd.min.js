/*!
 * vue3-treeselect v0.1.4 | (c) 2024 Andreas Johansson
 * Released under the MIT License.
 * https://vue3-treeselect.js.org/
 */
!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var t=n();for(var r in t)("object"==typeof exports?exports:e)[r]=t[r]}}(self,(function(){return function(){"use strict";var __webpack_modules__={"./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/function(__unused_webpack_module,exports){eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports["default"] = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};\n\n//# sourceURL=webpack://@chege-simon/vue3-treeselect/./node_modules/vue-loader/dist/exportHelper.js?')},"./src/index.js":
/*!***********************************!*\
  !*** ./src/index.js + 79 modules ***!
  \***********************************/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  ASYNC_SEARCH: function() { return /* reexport */ ASYNC_SEARCH; },\n  LOAD_CHILDREN_OPTIONS: function() { return /* reexport */ LOAD_CHILDREN_OPTIONS; },\n  LOAD_ROOT_OPTIONS: function() { return /* reexport */ LOAD_ROOT_OPTIONS; },\n  Treeselect: function() { return /* reexport */ Treeselect; },\n  VERSION: function() { return /* binding */ VERSION; },\n  "default": function() { return /* binding */ src; },\n  treeselectMixin: function() { return /* reexport */ treeselectMixin; }\n});\n\n;// CONCATENATED MODULE: external "vue"\nvar external_vue_namespaceObject = require("vue");\n;// CONCATENATED MODULE: external "fuzzysearch"\nvar external_fuzzysearch_namespaceObject = require("fuzzysearch");\nvar external_fuzzysearch_default = /*#__PURE__*/__webpack_require__.n(external_fuzzysearch_namespaceObject);\n;// CONCATENATED MODULE: external "lodash/noop"\nvar noop_namespaceObject = require("lodash/noop");\n;// CONCATENATED MODULE: ./src/utils/noop.js\n\n;// CONCATENATED MODULE: ./src/utils/warning.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nvar warning =  false ? /* istanbul ignore next */0 : function warning(checker, complainer) {\n  if (!checker()) {\n    var _console;\n    var message = ["[Vue3-Treeselect Warning]"].concat(complainer());\n    // eslint-disable-next-line no-console\n    (_console = console).error.apply(_console, _toConsumableArray(message));\n  }\n};\n;// CONCATENATED MODULE: ./src/utils/onLeftClick.js\nfunction onLeftClick(mouseDownHandler) {\n  return function onMouseDown(evt) {\n    if (evt.type === "mousedown" && evt.button === 0) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      mouseDownHandler.call.apply(mouseDownHandler, [this, evt].concat(args));\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/utils/scrollIntoView.js\n// from react-select\nfunction scrollIntoView($scrollingEl, $focusedEl) {\n  var scrollingReact = $scrollingEl.getBoundingClientRect();\n  var focusedRect = $focusedEl.getBoundingClientRect();\n  var overScroll = $focusedEl.offsetHeight / 3;\n  if (focusedRect.bottom + overScroll > scrollingReact.bottom) {\n    $scrollingEl.scrollTop = Math.min($focusedEl.offsetTop + $focusedEl.clientHeight - $scrollingEl.offsetHeight + overScroll, $scrollingEl.scrollHeight);\n  } else if (focusedRect.top - overScroll < scrollingReact.top) {\n    $scrollingEl.scrollTop = Math.max($focusedEl.offsetTop - overScroll, 0);\n  }\n}\n;// CONCATENATED MODULE: external "lodash/debounce"\nvar debounce_namespaceObject = require("lodash/debounce");\nvar debounce_default = /*#__PURE__*/__webpack_require__.n(debounce_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/debounce.js\n\n;// CONCATENATED MODULE: external "watch-size"\nvar external_watch_size_namespaceObject = require("watch-size");\nvar external_watch_size_default = /*#__PURE__*/__webpack_require__.n(external_watch_size_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/removeFromArray.js\nfunction removeFromArray(arr, elem) {\n  var idx = arr.indexOf(elem);\n  if (idx !== -1) {\n    arr.splice(idx, 1);\n  }\n}\n;// CONCATENATED MODULE: ./src/utils/watchSize.js\n\n\nvar intervalId;\nvar registered = [];\nvar INTERVAL_DURATION = 100;\nfunction run() {\n  intervalId = setInterval(function () {\n    registered.forEach(test);\n  }, INTERVAL_DURATION);\n}\nfunction stop() {\n  clearInterval(intervalId);\n  intervalId = null;\n}\nfunction test(item) {\n  var $el = item.$el,\n    listener = item.listener,\n    lastWidth = item.lastWidth,\n    lastHeight = item.lastHeight;\n  var width = $el.offsetWidth;\n  var height = $el.offsetHeight;\n  if (lastWidth !== width || lastHeight !== height) {\n    item.lastWidth = width;\n    item.lastHeight = height;\n    listener({\n      width: width,\n      height: height\n    });\n  }\n}\nfunction watchSizeForIE9($el, listener) {\n  var item = {\n    $el: $el,\n    listener: listener,\n    lastWidth: null,\n    lastHeight: null\n  };\n  var unwatch = function unwatch() {\n    removeFromArray(registered, item);\n    if (!registered.length) {\n      stop();\n    }\n  };\n  registered.push(item);\n  // The original watch-size will call the listener on initialization.\n  // Keep the same behavior here.\n  test(item);\n  run();\n  return unwatch;\n}\nfunction watchSize($el, listener) {\n  // See: https://stackoverflow.com/a/31293352\n  var isIE9 = document.documentMode === 9;\n  // watch-size will call the listener on initialization.\n  // Disable this behavior with a lock to achieve a clearer code logic.\n  var locked = true;\n  var wrappedListener = function wrappedListener() {\n    return locked || listener.apply(void 0, arguments);\n  };\n  var implementation = isIE9 ? watchSizeForIE9 : (external_watch_size_default());\n  var removeSizeWatcher = implementation($el, wrappedListener);\n  locked = false; // unlock after initialization\n\n  return removeSizeWatcher;\n}\n;// CONCATENATED MODULE: ./src/utils/setupResizeAndScrollEventListeners.js\nfunction findScrollParents($el) {\n  var $scrollParents = [];\n  var $parent = $el.parentNode;\n  while ($parent && $parent.nodeName !== "BODY" && $parent.nodeType === document.ELEMENT_NODE) {\n    if (isScrollElment($parent)) {\n      $scrollParents.push($parent);\n    }\n    $parent = $parent.parentNode;\n  }\n  $scrollParents.push(window);\n  return $scrollParents;\n}\nfunction isScrollElment($el) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle($el),\n    overflow = _getComputedStyle.overflow,\n    overflowX = _getComputedStyle.overflowX,\n    overflowY = _getComputedStyle.overflowY;\n  return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX);\n}\nfunction setupResizeAndScrollEventListeners($el, listener) {\n  var $scrollParents = findScrollParents($el);\n  window.addEventListener("resize", listener, {\n    passive: true\n  });\n  $scrollParents.forEach(function (scrollParent) {\n    scrollParent.addEventListener("scroll", listener, {\n      passive: true\n    });\n  });\n  return function removeEventListeners() {\n    window.removeEventListener("resize", listener, {\n      passive: true\n    });\n    $scrollParents.forEach(function ($scrollParent) {\n      $scrollParent.removeEventListener("scroll", listener, {\n        passive: true\n      });\n    });\n  };\n}\n;// CONCATENATED MODULE: ./src/utils/isNaN.js\nfunction isNaN_isNaN(x) {\n  return x !== x;\n}\n;// CONCATENATED MODULE: external "is-promise"\nvar external_is_promise_namespaceObject = require("is-promise");\nvar external_is_promise_default = /*#__PURE__*/__webpack_require__.n(external_is_promise_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/isPromise.js\n\n;// CONCATENATED MODULE: external "lodash/once"\nvar once_namespaceObject = require("lodash/once");\nvar once_default = /*#__PURE__*/__webpack_require__.n(once_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/once.js\n\n;// CONCATENATED MODULE: external "lodash/identity"\nvar identity_namespaceObject = require("lodash/identity");\nvar identity_default = /*#__PURE__*/__webpack_require__.n(identity_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/identity.js\n\n;// CONCATENATED MODULE: external "lodash/constant"\nvar constant_namespaceObject = require("lodash/constant");\nvar constant_default = /*#__PURE__*/__webpack_require__.n(constant_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/constant.js\n\n;// CONCATENATED MODULE: ./src/utils/createMap.js\nvar createMap = function createMap() {\n  return Object.create(null);\n};\n;// CONCATENATED MODULE: ./src/utils/deepExtend.js\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction isPlainObject(value) {\n  if (value == null || _typeof(value) !== "object") {\n    return false;\n  }\n  return Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction copy(obj, key, value) {\n  if (isPlainObject(value)) {\n    obj[key] || (obj[key] = {});\n    deepExtend(obj[key], value);\n  } else {\n    obj[key] = value;\n  }\n}\nfunction deepExtend(target, source) {\n  if (isPlainObject(source)) {\n    var keys = Object.keys(source);\n    for (var i = 0, len = keys.length; i < len; i++) {\n      copy(target, keys[i], source[keys[i]]);\n    }\n  }\n  return target;\n}\n;// CONCATENATED MODULE: external "lodash/last"\nvar last_namespaceObject = require("lodash/last");\nvar last_default = /*#__PURE__*/__webpack_require__.n(last_namespaceObject);\n;// CONCATENATED MODULE: ./src/utils/last.js\n\n;// CONCATENATED MODULE: ./src/utils/includes.js\nfunction includes(arrOrStr, elem) {\n  return arrOrStr.indexOf(elem) !== -1;\n}\n;// CONCATENATED MODULE: ./src/utils/find.js\nfunction find(arr, predicate, ctx) {\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (predicate.call(ctx, arr[i], i, arr)) {\n      return arr[i];\n    }\n  }\n  return undefined;\n}\n;// CONCATENATED MODULE: ./src/utils/quickDiff.js\nfunction quickDiff(arrA, arrB) {\n  if (arrA.length !== arrB.length) {\n    return true;\n  }\n  for (var i = 0; i < arrA.length; i++) {\n    if (arrA[i] !== arrB[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n;// CONCATENATED MODULE: ./src/utils/index.js\n// ========================\n// Debugging Helpers\n// ========================\n\n\n\n// ========================\n// DOM Utilities\n// ========================\n\n\n\n\n\n\n\n// ========================\n// Language Helpers\n// ========================\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ========================\n// Other Utilities\n// ========================\n\n\n;// CONCATENATED MODULE: ./src/constants.js\n// Magic value that indicates a root level node.\nvar NO_PARENT_NODE = null;\n\n// Types of checked state.\nvar UNCHECKED = 0;\nvar INDETERMINATE = 1;\nvar CHECKED = 2;\n\n// Types of count number.\nvar ALL_CHILDREN = "ALL_CHILDREN";\nvar ALL_DESCENDANTS = "ALL_DESCENDANTS";\nvar LEAF_CHILDREN = "LEAF_CHILDREN";\nvar LEAF_DESCENDANTS = "LEAF_DESCENDANTS";\n\n// Action types of delayed loading.\nvar LOAD_ROOT_OPTIONS = "LOAD_ROOT_OPTIONS";\nvar LOAD_CHILDREN_OPTIONS = "LOAD_CHILDREN_OPTIONS";\nvar ASYNC_SEARCH = "ASYNC_SEARCH";\n\n// Acceptable values of `valueConsistsOf` prop.\nvar ALL = "ALL";\nvar BRANCH_PRIORITY = "BRANCH_PRIORITY";\nvar LEAF_PRIORITY = "LEAF_PRIORITY";\nvar ALL_WITH_INDETERMINATE = "ALL_WITH_INDETERMINATE";\n\n// Acceptable values of `sortValueBy` prop.\nvar ORDER_SELECTED = "ORDER_SELECTED";\nvar LEVEL = "LEVEL";\nvar INDEX = "INDEX";\n\n// Key codes look-up table.\nvar KEY_CODES = {\n  BACKSPACE: 8,\n  ENTER: 13,\n  ESCAPE: 27,\n  END: 35,\n  HOME: 36,\n  ARROW_LEFT: 37,\n  ARROW_UP: 38,\n  ARROW_RIGHT: 39,\n  ARROW_DOWN: 40,\n  DELETE: 46\n};\n\n// Other constants.\nvar INPUT_DEBOUNCE_DELAY =  false ? /* to speed up unit testing */0 : /* istanbul ignore next */200;\nvar MIN_INPUT_WIDTH = 5;\nvar MENU_BUFFER = 40;\n;// CONCATENATED MODULE: ./src/mixins/treeselectMixin.js\nfunction treeselectMixin_typeof(o) { "@babel/helpers - typeof"; return treeselectMixin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, treeselectMixin_typeof(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || treeselectMixin_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction treeselectMixin_toConsumableArray(arr) { return treeselectMixin_arrayWithoutHoles(arr) || treeselectMixin_iterableToArray(arr) || treeselectMixin_unsupportedIterableToArray(arr) || treeselectMixin_nonIterableSpread(); }\nfunction treeselectMixin_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction treeselectMixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treeselectMixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treeselectMixin_arrayLikeToArray(o, minLen); }\nfunction treeselectMixin_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction treeselectMixin_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treeselectMixin_arrayLikeToArray(arr); }\nfunction treeselectMixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return treeselectMixin_typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (treeselectMixin_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (treeselectMixin_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nfunction sortValueByIndex(a, b) {\n  var i = 0;\n  do {\n    if (a.level < i) {\n      return -1;\n    }\n    if (b.level < i) {\n      return 1;\n    }\n    if (a.index[i] !== b.index[i]) {\n      return a.index[i] - b.index[i];\n    }\n    i++;\n  } while (true);\n}\nfunction sortValueByLevel(a, b) {\n  return a.level === b.level ? sortValueByIndex(a, b) : a.level - b.level;\n}\nfunction createAsyncOptionsStates() {\n  return {\n    isLoaded: false,\n    isLoading: false,\n    loadingError: ""\n  };\n}\nfunction stringifyOptionPropValue(value) {\n  if (typeof value === "string") {\n    return value;\n  }\n  if (typeof value === "number" && !isNaN_isNaN(value)) {\n    return value + "";\n  }\n  // istanbul ignore next\n  return "";\n}\nfunction match(enableFuzzyMatch, needle, haystack) {\n  return enableFuzzyMatch ? external_fuzzysearch_default()(needle, haystack) : includes(haystack, needle);\n}\nfunction getErrorMessage(err) {\n  return err.message || /* istanbul ignore next */String(err);\n}\nvar instanceId = 0;\n/* harmony default export */ var treeselectMixin = ({\n  provide: function provide() {\n    return {\n      // Enable access to the instance of root component of vue3-treeselect\n      // across hierarchy.\n      instance: this\n    };\n  },\n  props: {\n    /**\r\n     * Whether to allow resetting value even if there are disabled selected nodes.\r\n     */\n    allowClearingDisabled: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * When an ancestor node is selected/deselected, whether its disabled descendants should be selected/deselected.\r\n     * You may want to use this in conjunction with `allowClearingDisabled` prop.\r\n     */\n    allowSelectingDisabledDescendants: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Whether the menu should be always open.\r\n     */\n    alwaysOpen: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Append the menu to <body />?\r\n     */\n    appendToBody: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Whether to enable async search mode.\r\n     */\n    async: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Automatically focus the component on mount?\r\n     */\n    autoFocus: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Automatically load root options on mount. When set to `false`, root options will be loaded when the menu is opened.\r\n     */\n    autoLoadRootOptions: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * When user deselects a node, automatically deselect its ancestors. Applies to flat mode only.\r\n     */\n    autoDeselectAncestors: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * When user deselects a node, automatically deselect its descendants. Applies to flat mode only.\r\n     */\n    autoDeselectDescendants: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * When user selects a node, automatically select its ancestors. Applies to flat mode only.\r\n     */\n    autoSelectAncestors: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * When user selects a node, automatically select its descendants. Applies to flat mode only.\r\n     */\n    autoSelectDescendants: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Whether pressing backspace key removes the last item if there is no text input.\r\n     */\n    backspaceRemoves: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Function that processes before clearing all input fields.\r\n     * Return `false` to prevent value from being cleared.\r\n     * @type {function(): (boolean|Promise<boolean>)}\r\n     */\n    beforeClearAll: {\n      type: Function,\n      default: constant_default()(true)\n    },\n    /**\r\n     * Show branch nodes before leaf nodes?\r\n     */\n    branchNodesFirst: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Should cache results of every search request?\r\n     */\n    cacheOptions: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Show an "×" button that resets value?\r\n     */\n    clearable: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Title for the "×" button when `multiple: true`.\r\n     */\n    clearAllText: {\n      type: String,\n      default: "Clear all"\n    },\n    /**\r\n     * Whether to clear the search input after selecting.\r\n     * Use only when `multiple` is `true`.\r\n     * For single-select mode, it **always** clears the input after selecting an option regardless of the prop value.\r\n     */\n    clearOnSelect: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Title for the "×" button.\r\n     */\n    clearValueText: {\n      type: String,\n      default: "Clear value"\n    },\n    /**\r\n     * Whether to close the menu after selecting an option?\r\n     * Use only when `multiple` is `true`.\r\n     */\n    closeOnSelect: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * How many levels of branch nodes should be automatically expanded when loaded.\r\n     * Set `Infinity` to make all branch nodes expanded by default.\r\n     */\n    defaultExpandLevel: {\n      type: Number,\n      default: 0\n    },\n    /**\r\n     * Whether pressing delete key removes the last item if there is no text input.\r\n     */\n    deleteRemoves: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Delimiter to use to join multiple values for the hidden field value.\r\n     */\n    delimiter: {\n      type: String,\n      default: ","\n    },\n    /**\r\n     * Only show the nodes that match the search value directly, excluding its ancestors.\r\n     *\r\n     * @type {Object}\r\n     */\n    flattenSearchResults: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Prevent branch nodes from being selected?\r\n     */\n    disableBranchNodes: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Disable the control?\r\n     */\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Disable the fuzzy matching functionality?\r\n     */\n    disableFuzzyMatching: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Whether to enable flat mode or not. Non-flat mode (default) means:\r\n     *   - Whenever a branch node gets checked, all its children will be checked too\r\n     *   - Whenever a branch node has all children checked, the branch node itself will be checked too\r\n     * Set `true` to disable this mechanism\r\n     */\n    flat: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Will be passed with all events as the last param.\r\n     * Useful for identifying events origin.\r\n     */\n    instanceId: {\n      // Add two trailing "$" to distinguish from explictly specified ids.\n      default: function _default() {\n        return "".concat(instanceId++, "$$");\n      },\n      type: [String, Number]\n    },\n    /**\r\n     * Joins multiple values into a single form field with the `delimiter` (legacy mode).\r\n     */\n    joinValues: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Limit the display of selected options.\r\n     * The rest will be hidden within the limitText string.\r\n     */\n    limit: {\n      type: Number,\n      default: Infinity\n    },\n    /**\r\n     * Function that processes the message shown when selected elements pass the defined limit.\r\n     * @type {function(number): string}\r\n     */\n    limitText: {\n      type: Function,\n      default: function limitTextDefault(count) {\n        // eslint-disable-line func-name-matching\n        return "and ".concat(count, " more");\n      }\n    },\n    /**\r\n     * Text displayed when loading options.\r\n     */\n    loadingText: {\n      type: String,\n      default: "Loading..."\n    },\n    /**\r\n     * Used for dynamically loading options.\r\n     * @type {function({action: string, callback: (function((Error|string)=): void), parentNode: node=, instanceId}): void}\r\n     */\n    loadOptions: {\n      type: Function\n    },\n    /**\r\n     * Which node properties to filter on.\r\n     */\n    matchKeys: {\n      type: Array,\n      default: constant_default()(["label"])\n    },\n    /**\r\n     * Sets `maxHeight` style value of the menu.\r\n     */\n    maxHeight: {\n      type: Number,\n      default: 300\n    },\n    /**\r\n     * Set `true` to allow selecting multiple options (a.k.a., multi-select mode).\r\n     */\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Generates a hidden <input /> tag with this field name for html forms.\r\n     */\n    name: {\n      type: String\n    },\n    /**\r\n     * Text displayed when a branch node has no children.\r\n     */\n    noChildrenText: {\n      type: String,\n      default: "No sub-options."\n    },\n    /**\r\n     * Text displayed when there are no available options.\r\n     */\n    noOptionsText: {\n      type: String,\n      default: "No options available."\n    },\n    /**\r\n     * Text displayed when there are no matching search results.\r\n     */\n    noResultsText: {\n      type: String,\n      default: "No results found..."\n    },\n    /**\r\n     * Used for normalizing source data.\r\n     * @type {function(node, instanceId): node}\r\n     */\n    normalizer: {\n      type: Function,\n      default: (identity_default())\n    },\n    /**\r\n     * By default (`auto`), the menu will open below the control. If there is not\r\n     * enough space, vue3-treeselect will automatically flip the menu.\r\n     * You can use one of other four options to force the menu to be always opened\r\n     * to specified direction.\r\n     * Acceptable values:\r\n     *   - `"auto"`\r\n     *   - `"below"`\r\n     *   - `"bottom"`\r\n     *   - `"above"`\r\n     *   - `"top"`\r\n     */\n    openDirection: {\n      type: String,\n      default: "auto",\n      validator: function validator(value) {\n        var acceptableValues = ["auto", "top", "bottom", "above", "below"];\n        return includes(acceptableValues, value);\n      }\n    },\n    /**\r\n     * Whether to automatically open the menu when the control is clicked.\r\n     */\n    openOnClick: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Whether to automatically open the menu when the control is focused.\r\n     */\n    openOnFocus: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Array of available options.\r\n     * @type {node[]}\r\n     */\n    options: {\n      type: Array\n    },\n    /**\r\n     * Field placeholder, displayed when there\'s no value.\r\n     */\n    placeholder: {\n      type: String,\n      default: "Select..."\n    },\n    /**\r\n     * Applies HTML5 required attribute when needed.\r\n     */\n    required: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Text displayed asking user whether to retry loading children options.\r\n     */\n    retryText: {\n      type: String,\n      default: "Retry?"\n    },\n    /**\r\n     * Title for the retry button.\r\n     */\n    retryTitle: {\n      type: String,\n      default: "Click to retry"\n    },\n    /**\r\n     * Enable searching feature?\r\n     */\n    searchable: {\n      type: Boolean,\n      default: true\n    },\n    /**\r\n     * Search in ancestor nodes too.\r\n     */\n    searchNested: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Text tip to prompt for async search.\r\n     */\n    searchPromptText: {\n      type: String,\n      default: "Type to search..."\n    },\n    /**\r\n     * Whether to show a children count next to the label of each branch node.\r\n     */\n    showCount: {\n      type: Boolean,\n      default: false\n    },\n    /**\r\n     * Used in conjunction with `showCount` to specify which type of count number should be displayed.\r\n     * Acceptable values:\r\n     *   - "ALL_CHILDREN"\r\n     *   - "ALL_DESCENDANTS"\r\n     *   - "LEAF_CHILDREN"\r\n     *   - "LEAF_DESCENDANTS"\r\n     */\n    showCountOf: {\n      type: String,\n      default: ALL_CHILDREN,\n      validator: function validator(value) {\n        var acceptableValues = [ALL_CHILDREN, ALL_DESCENDANTS, LEAF_CHILDREN, LEAF_DESCENDANTS];\n        return includes(acceptableValues, value);\n      }\n    },\n    /**\r\n     * Whether to show children count when searching.\r\n     * Fallbacks to the value of `showCount` when not specified.\r\n     * @type {boolean}\r\n     */\n    showCountOnSearch: null,\n    /**\r\n     * In which order the selected options should be displayed in trigger & sorted in `value` array.\r\n     * Used for multi-select mode only.\r\n     * Acceptable values:\r\n     *   - "ORDER_SELECTED"\r\n     *   - "LEVEL"\r\n     *   - "INDEX"\r\n     */\n    sortValueBy: {\n      type: String,\n      default: ORDER_SELECTED,\n      validator: function validator(value) {\n        var acceptableValues = [ORDER_SELECTED, LEVEL, INDEX];\n        return includes(acceptableValues, value);\n      }\n    },\n    /**\r\n     * Tab index of the control.\r\n     */\n    tabIndex: {\n      type: Number,\n      default: 0\n    },\n    /**\r\n     * The value of the control.\r\n     * Should be `id` or `node` object for single-select mode, or an array of `id` or `node` object for multi-select mode.\r\n     * Its format depends on the `valueFormat` prop.\r\n     * For most cases, just use `v-model` instead.\r\n     * @type {?Array}\r\n     */\n    modelValue: null,\n    /**\r\n     * Which kind of nodes should be included in the `value` array in multi-select mode.\r\n     * Acceptable values:\r\n     *   - "ALL" - Any node that is checked will be included in the `value` array\r\n     *   - "BRANCH_PRIORITY" (default) - If a branch node is checked, all its descendants will be excluded in the `value` array\r\n     *   - "LEAF_PRIORITY" - If a branch node is checked, this node itself and its branch descendants will be excluded from the `value` array but its leaf descendants will be included\r\n     *   - "ALL_WITH_INDETERMINATE" - Any node that is checked will be included in the `value` array, plus indeterminate nodes\r\n     */\n    valueConsistsOf: {\n      type: String,\n      default: BRANCH_PRIORITY,\n      validator: function validator(value) {\n        var acceptableValues = [ALL, BRANCH_PRIORITY, LEAF_PRIORITY, ALL_WITH_INDETERMINATE];\n        return includes(acceptableValues, value);\n      }\n    },\n    /**\r\n     * Format of `value` prop.\r\n     * Note that, when set to `"object"`, only `id` & `label` properties are required in each `node` object in `value` prop.\r\n     * Acceptable values:\r\n     *   - "id"\r\n     *   - "object"\r\n     */\n    valueFormat: {\n      type: String,\n      default: "id"\n    },\n    /**\r\n     * z-index of the menu.\r\n     */\n    zIndex: {\n      type: [Number, String],\n      default: 999\n    }\n  },\n  data: function data() {\n    return {\n      trigger: {\n        // Is the control focused?\n        isFocused: false,\n        // User entered search query - value of the input.\n        searchQuery: ""\n      },\n      menu: {\n        // Is the menu opened?\n        isOpen: false,\n        // Id of current highlighted option.\n        current: null,\n        // The scroll position before last menu closing.\n        lastScrollPosition: 0,\n        // Which direction to open the menu.\n        placement: "bottom",\n        renderKey: 0\n      },\n      forest: {\n        // Normalized options.\n        normalizedOptions: [],\n        // <id, node> map for quick look-up.\n        nodeMap: createMap(),\n        // <id, checkedState> map, used for multi-select mode.\n        checkedStateMap: createMap(),\n        // Id list of all selected options.\n        selectedNodeIds: this.extractCheckedNodeIdsFromValue(),\n        // <id, true> map for fast checking:\n        //   if (forest.selectedNodeIds.indexOf(id) !== -1) forest.selectedNodeMap[id] === true\n        selectedNodeMap: createMap()\n      },\n      // States of root options.\n      rootOptionsStates: createAsyncOptionsStates(),\n      localSearch: {\n        // Has user entered any query to search local options?\n        active: false,\n        // Has any options matched the search query?\n        noResults: true,\n        // <id, countObject> map for counting matched children/descendants.\n        countMap: createMap()\n      },\n      // <searchQuery, remoteSearchEntry> map.\n      remoteSearch: createMap(),\n      // Is there any branch node?\n      hasBranchNodes: false\n    };\n  },\n  computed: {\n    /* eslint-disable valid-jsdoc */\n    /**\r\n     * Normalized nodes that have been selected.\r\n     * @type {node[]}\r\n     */\n    selectedNodes: function selectedNodes() {\n      return this.forest.selectedNodeIds.map(this.getNode);\n    },\n    /**\r\n     * Id list of selected nodes with `sortValueBy` prop applied.\r\n     * @type {nodeId[]}\r\n     */\n    internalValue: function internalValue() {\n      var _this = this;\n      var internalValue;\n\n      // istanbul ignore else\n      if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {\n        internalValue = this.forest.selectedNodeIds.slice();\n      } else if (this.valueConsistsOf === BRANCH_PRIORITY) {\n        internalValue = this.forest.selectedNodeIds.filter(function (id) {\n          var node = _this.getNode(id);\n          if (node.isRootNode) {\n            return true;\n          }\n          return !_this.isSelected(node.parentNode);\n        });\n      } else if (this.valueConsistsOf === LEAF_PRIORITY) {\n        internalValue = this.forest.selectedNodeIds.filter(function (id) {\n          var node = _this.getNode(id);\n          if (node.isLeaf) {\n            return true;\n          }\n          return node.children.length === 0;\n        });\n      } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {\n        var _internalValue;\n        var indeterminateNodeIds = [];\n        internalValue = this.forest.selectedNodeIds.slice();\n        this.selectedNodes.forEach(function (selectedNode) {\n          selectedNode.ancestors.forEach(function (ancestor) {\n            if (includes(indeterminateNodeIds, ancestor.id)) {\n              return;\n            }\n            if (includes(internalValue, ancestor.id)) {\n              return;\n            }\n            indeterminateNodeIds.push(ancestor.id);\n          });\n        });\n        (_internalValue = internalValue).push.apply(_internalValue, indeterminateNodeIds);\n      }\n      if (this.sortValueBy === LEVEL) {\n        internalValue.sort(function (a, b) {\n          return sortValueByLevel(_this.getNode(a), _this.getNode(b));\n        });\n      } else if (this.sortValueBy === INDEX) {\n        internalValue.sort(function (a, b) {\n          return sortValueByIndex(_this.getNode(a), _this.getNode(b));\n        });\n      }\n      return internalValue;\n    },\n    /**\r\n     * Has any option been selected?\r\n     * @type {boolean}\r\n     */\n    hasValue: function hasValue() {\n      return this.internalValue.length > 0;\n    },\n    /**\r\n     * Single-select mode?\r\n     * @type {boolean}\r\n     */\n    single: function single() {\n      return !this.multiple;\n    },\n    /**\r\n     * Id list of nodes displayed in the menu. Nodes that are considered NOT visible:\r\n     *   - descendants of a collapsed branch node\r\n     *   - in local search mode, nodes that are not matched, unless\r\n     *       - it\'s a branch node and has matched descendants\r\n     *       - it\'s a leaf node and its parent node is explicitly set to show all children\r\n     * @type {id[]}\r\n     */\n    visibleOptionIds: function visibleOptionIds() {\n      var _this2 = this;\n      var visibleOptionIds = [];\n      this.traverseAllNodesByIndex(function (node) {\n        if (!_this2.localSearch.active || _this2.shouldOptionBeIncludedInSearchResult(node)) {\n          visibleOptionIds.push(node.id);\n        }\n        // Skip the traversal of descendants of a branch node if it\'s not expanded.\n        if (node.isBranch && !_this2.shouldExpand(node)) {\n          return false;\n        }\n      });\n      return visibleOptionIds;\n    },\n    /**\r\n     * Has any option should be displayed in the menu?\r\n     * @type {boolean}\r\n     */\n    hasVisibleOptions: function hasVisibleOptions() {\n      return this.visibleOptionIds.length !== 0;\n    },\n    /**\r\n     * Should show children count when searching?\r\n     * @type {boolean}\r\n     */\n    showCountOnSearchComputed: function showCountOnSearchComputed() {\n      // Vue doesn\'t allow setting default prop value based on another prop value.\n      // So use computed property as a workaround.\n      // https://github.com/vuejs/vue/issues/6358\n      return typeof this.showCountOnSearch === "boolean" ? this.showCountOnSearch : this.showCount;\n    },\n    shouldFlattenOptions: function shouldFlattenOptions() {\n      return this.localSearch.active && this.flattenSearchResults;\n    } /* eslint-enable valid-jsdoc */\n  },\n  watch: {\n    alwaysOpen: function alwaysOpen(newValue) {\n      if (newValue) {\n        this.openMenu();\n      } else {\n        this.closeMenu();\n      }\n    },\n    branchNodesFirst: function branchNodesFirst() {\n      this.initialize();\n    },\n    disabled: function disabled(newValue) {\n      // force close the menu after disabling the control\n      if (newValue && this.menu.isOpen) {\n        this.closeMenu();\n      } else if (!newValue && !this.menu.isOpen && this.alwaysOpen) {\n        this.openMenu();\n      }\n    },\n    flat: function flat() {\n      this.initialize();\n    },\n    internalValue: function internalValue(newValue, oldValue) {\n      var hasChanged = quickDiff(newValue, oldValue);\n      // #122\n      // Vue would trigger this watcher when `newValue` and `oldValue` are shallow-equal.\n      // We emit the `input` event only when the value actually changes.\n      if (hasChanged) {\n        this.$emit("update:modelValue", this.getValue(), this.getInstanceId());\n      }\n    },\n    matchKeys: function matchKeys() {\n      this.initialize();\n    },\n    multiple: function multiple(newValue) {\n      // We need to rebuild the state when switching from single-select mode\n      // to multi-select mode.\n      // istanbul ignore else\n      if (newValue) {\n        this.buildForestState();\n      }\n    },\n    options: {\n      handler: function handler() {\n        if (this.async) {\n          return;\n        }\n        // Re-initialize options when the `options` prop has changed.\n        this.initialize();\n        this.rootOptionsStates.isLoaded = Array.isArray(this.options);\n      },\n      deep: true,\n      immediate: true\n    },\n    "trigger.searchQuery": function triggerSearchQuery() {\n      if (this.async) {\n        this.handleRemoteSearch();\n      } else {\n        this.handleLocalSearch();\n      }\n      this.$emit("search-change", this.trigger.searchQuery, this.getInstanceId());\n    },\n    modelValue: function modelValue() {\n      var nodeIdsFromValue = this.extractCheckedNodeIdsFromValue();\n      var hasChanged = quickDiff(nodeIdsFromValue, this.internalValue);\n      if (hasChanged) {\n        this.fixSelectedNodeIds(nodeIdsFromValue);\n      }\n    }\n  },\n  methods: {\n    verifyProps: function verifyProps() {\n      var _this3 = this;\n      warning(function () {\n        return _this3.async ? _this3.searchable : true;\n      }, function () {\n        return \'For async search mode, the value of "searchable" prop must be true.\';\n      });\n      if (this.options == null && !this.loadOptions) {\n        warning(function () {\n          return false;\n        }, function () {\n          return \'Are you meant to dynamically load options? You need to use "loadOptions" prop.\';\n        });\n      }\n      if (this.flat) {\n        warning(function () {\n          return _this3.multiple;\n        }, function () {\n          return \'You are using flat mode. But you forgot to add "multiple=true"?\';\n        });\n      }\n      if (!this.flat) {\n        var propNames = ["autoSelectAncestors", "autoSelectDescendants", "autoDeselectAncestors", "autoDeselectDescendants"];\n        propNames.forEach(function (propName) {\n          warning(function () {\n            return !_this3[propName];\n          }, function () {\n            return "\\"".concat(propName, "\\" only applies to flat mode.");\n          });\n        });\n      }\n    },\n    resetFlags: function resetFlags() {\n      this._blurOnSelect = false;\n    },\n    initialize: function initialize() {\n      var options = this.async ? this.getRemoteSearchEntry().options : this.options;\n      if (Array.isArray(options)) {\n        // In case we are re-initializing options, keep the old state tree temporarily.\n        var prevNodeMap = this.forest.nodeMap;\n        this.forest.nodeMap = createMap();\n        this.keepDataOfSelectedNodes(prevNodeMap);\n        this.forest.normalizedOptions = this.normalize(NO_PARENT_NODE, options, prevNodeMap);\n        // Cases that need fixing `selectedNodeIds`:\n        //   1) Children options of a checked node have been delayed loaded,\n        //      we should also mark these children as checked. (multi-select mode)\n        //   2) Root options have been delayed loaded, we need to initialize states\n        //      of these nodes. (multi-select mode)\n        //   3) Async search mode.\n        this.fixSelectedNodeIds(this.internalValue);\n        this.hasBranchNodes = this.forest.normalizedOptions.some(function (rootNode) {\n          return rootNode.isBranch;\n        });\n      } else {\n        this.forest.normalizedOptions = [];\n      }\n    },\n    getInstanceId: function getInstanceId() {\n      return this.instanceId == null ? this.id : this.instanceId;\n    },\n    getValue: function getValue() {\n      var _this4 = this;\n      if (this.valueFormat === "id") {\n        return this.multiple ? this.internalValue.slice() : this.internalValue[0];\n      }\n      var rawNodes = this.internalValue.map(function (id) {\n        return _this4.getNode(id).raw;\n      });\n      return this.multiple ? rawNodes : rawNodes[0];\n    },\n    getNode: function getNode(nodeId) {\n      warning(function () {\n        return nodeId != null;\n      }, function () {\n        return "Invalid node id: ".concat(nodeId);\n      });\n      if (nodeId == null) {\n        return null;\n      }\n      return nodeId in this.forest.nodeMap ? this.forest.nodeMap[nodeId] : this.createFallbackNode(nodeId);\n    },\n    createFallbackNode: function createFallbackNode(id) {\n      // In case there is a default selected node that is not loaded into the tree yet,\n      // we create a fallback node to keep the component working.\n      // When the real data is loaded, we\'ll override this fake node.\n\n      var raw = this.extractNodeFromValue(id);\n      var label = this.enhancedNormalizer(raw).label || "".concat(id, " (unknown)");\n      var fallbackNode = {\n        id: id,\n        label: label,\n        ancestors: [],\n        parentNode: NO_PARENT_NODE,\n        isFallbackNode: true,\n        isRootNode: true,\n        isLeaf: true,\n        isBranch: false,\n        isDisabled: false,\n        isNew: false,\n        index: [-1],\n        level: 0,\n        raw: raw\n      };\n      return this.forest.nodeMap[id] = fallbackNode;\n    },\n    extractCheckedNodeIdsFromValue: function extractCheckedNodeIdsFromValue() {\n      var _this5 = this;\n      if (this.modelValue == null) {\n        return [];\n      }\n      if (this.valueFormat === "id") {\n        return this.multiple ? this.modelValue.slice() : [this.modelValue];\n      }\n      return (this.multiple ? this.modelValue : [this.modelValue]).map(function (node) {\n        return _this5.enhancedNormalizer(node);\n      }).map(function (node) {\n        return node.id;\n      });\n    },\n    extractNodeFromValue: function extractNodeFromValue(id) {\n      var _this6 = this;\n      var defaultNode = {\n        id: id\n      };\n      if (this.valueFormat === "id") {\n        return defaultNode;\n      }\n      var valueArray = this.multiple ? Array.isArray(this.modelValue) ? this.modelValue : [] : this.modelValue ? [this.modelValue] : [];\n      var matched = find(valueArray, function (node) {\n        return node && _this6.enhancedNormalizer(node).id === id;\n      });\n      return matched || defaultNode;\n    },\n    fixSelectedNodeIds: function fixSelectedNodeIds(nodeIdListOfPrevValue) {\n      var _this7 = this;\n      var nextSelectedNodeIds = [];\n\n      // istanbul ignore else\n      if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {\n        nextSelectedNodeIds = nodeIdListOfPrevValue;\n      } else if (this.valueConsistsOf === BRANCH_PRIORITY) {\n        nodeIdListOfPrevValue.forEach(function (nodeId) {\n          nextSelectedNodeIds.push(nodeId);\n          var node = _this7.getNode(nodeId);\n          if (node.isBranch) {\n            _this7.traverseDescendantsBFS(node, function (descendant) {\n              nextSelectedNodeIds.push(descendant.id);\n            });\n          }\n        });\n      } else if (this.valueConsistsOf === LEAF_PRIORITY) {\n        var map = createMap();\n        var queue = nodeIdListOfPrevValue.slice();\n        while (queue.length) {\n          var nodeId = queue.shift();\n          var node = this.getNode(nodeId);\n          nextSelectedNodeIds.push(nodeId);\n          if (node.isRootNode) {\n            continue;\n          }\n          if (!(node.parentNode.id in map)) {\n            map[node.parentNode.id] = node.parentNode.children.length;\n          }\n          if (--map[node.parentNode.id] === 0) {\n            queue.push(node.parentNode.id);\n          }\n        }\n      } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {\n        var _map = createMap();\n        var _queue = nodeIdListOfPrevValue.filter(function (nodeId) {\n          var node = _this7.getNode(nodeId);\n          return node.isLeaf || node.children.length === 0;\n        });\n        while (_queue.length) {\n          var _nodeId = _queue.shift();\n          var _node = this.getNode(_nodeId);\n          nextSelectedNodeIds.push(_nodeId);\n          if (_node.isRootNode) {\n            continue;\n          }\n          if (!(_node.parentNode.id in _map)) {\n            _map[_node.parentNode.id] = _node.parentNode.children.length;\n          }\n          if (--_map[_node.parentNode.id] === 0) {\n            _queue.push(_node.parentNode.id);\n          }\n        }\n      }\n      var hasChanged = quickDiff(this.forest.selectedNodeIds, nextSelectedNodeIds);\n      // If `nextSelectedNodeIds` doesn\'t actually differ from old `selectedNodeIds`,\n      // we don\'t make the assignment to avoid triggering its watchers which may cause\n      // unnecessary calculations.\n      if (hasChanged) {\n        this.forest.selectedNodeIds = nextSelectedNodeIds;\n      }\n      this.buildForestState();\n    },\n    keepDataOfSelectedNodes: function keepDataOfSelectedNodes(prevNodeMap) {\n      var _this8 = this;\n      // In case there is any selected node that is not present in the new `options` array.\n      // It could be useful for async search mode.\n      this.forest.selectedNodeIds.forEach(function (id) {\n        if (!prevNodeMap[id]) {\n          return;\n        }\n        var node = _objectSpread(_objectSpread({}, prevNodeMap[id]), {}, {\n          isFallbackNode: true\n        });\n        _this8.forest.nodeMap[id] = node;\n      });\n    },\n    isSelected: function isSelected(node) {\n      // whether a node is selected (single-select mode) or fully-checked (multi-select mode)\n      return node && this.forest.selectedNodeMap[node.id] === true;\n    },\n    traverseDescendantsBFS: function traverseDescendantsBFS(parentNode, callback) {\n      // istanbul ignore if\n      if (!parentNode.isBranch) {\n        return;\n      }\n      var queue = parentNode.children.slice();\n      while (queue.length) {\n        var currNode = queue[0];\n        if (currNode.isBranch) {\n          queue.push.apply(queue, treeselectMixin_toConsumableArray(currNode.children));\n        }\n        callback(currNode);\n        queue.shift();\n      }\n    },\n    traverseDescendantsDFS: function traverseDescendantsDFS(parentNode, callback) {\n      var _this9 = this;\n      if (!parentNode.isBranch) {\n        return;\n      }\n      parentNode.children.forEach(function (child) {\n        // deep-level node first\n        _this9.traverseDescendantsDFS(child, callback);\n        callback(child);\n      });\n    },\n    traverseAllNodesDFS: function traverseAllNodesDFS(callback) {\n      var _this10 = this;\n      this.forest.normalizedOptions.forEach(function (rootNode) {\n        // deep-level node first\n        _this10.traverseDescendantsDFS(rootNode, callback);\n        callback(rootNode);\n      });\n    },\n    traverseAllNodesByIndex: function traverseAllNodesByIndex(callback) {\n      var walk = function walk(parentNode) {\n        parentNode.children.forEach(function (child) {\n          if (callback(child) !== false && child.isBranch) {\n            walk(child);\n          }\n        });\n      };\n\n      // To simplify the code logic of traversal,\n      // we create a fake root node that holds all the root options.\n      walk({\n        children: this.forest.normalizedOptions\n      });\n    },\n    toggleClickOutsideEvent: function toggleClickOutsideEvent(enabled) {\n      if (enabled) {\n        document.addEventListener("mousedown", this.handleClickOutside, false);\n      } else {\n        document.removeEventListener("mousedown", this.handleClickOutside, false);\n      }\n    },\n    getValueContainer: function getValueContainer() {\n      return this.$refs.control.$refs["value-container"];\n    },\n    getInput: function getInput() {\n      return this.getValueContainer().$refs.input;\n    },\n    focusInput: function focusInput() {\n      this.getInput().focus();\n    },\n    blurInput: function blurInput() {\n      this.getInput().blur();\n    },\n    handleMouseDown: onLeftClick(function handleMouseDown(evt) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      if (this.disabled) {\n        return;\n      }\n      var isClickedOnValueContainer = this.getValueContainer().$el.contains(evt.target);\n      if (isClickedOnValueContainer && !this.menu.isOpen && (this.openOnClick || this.trigger.isFocused)) {\n        this.openMenu();\n      }\n      if (this._blurOnSelect) {\n        this.blurInput();\n      } else {\n        // Focus the input or prevent blurring.\n        this.focusInput();\n      }\n      this.resetFlags();\n    }),\n    handleClickOutside: function handleClickOutside(evt) {\n      // istanbul ignore else\n      if (this.$refs.wrapper && !this.$refs.wrapper.contains(evt.target)) {\n        this.blurInput();\n        this.closeMenu();\n      }\n    },\n    handleLocalSearch: function handleLocalSearch() {\n      var _this11 = this;\n      var searchQuery = this.trigger.searchQuery;\n      var done = function done() {\n        return _this11.resetHighlightedOptionWhenNecessary(true);\n      };\n      if (!searchQuery) {\n        // Exit sync search mode.\n        this.localSearch.active = false;\n        return done();\n      }\n\n      // Enter sync search mode.\n      this.localSearch.active = true;\n\n      // Reset states.\n      this.localSearch.noResults = true;\n      this.traverseAllNodesDFS(function (node) {\n        if (node.isBranch) {\n          var _this11$localSearch$c;\n          node.isExpandedOnSearch = false;\n          node.showAllChildrenOnSearch = false;\n          node.isMatched = false;\n          node.hasMatchedDescendants = false;\n          _this11.localSearch.countMap[node.id] = (_this11$localSearch$c = {}, _defineProperty(_this11$localSearch$c, ALL_CHILDREN, 0), _defineProperty(_this11$localSearch$c, ALL_DESCENDANTS, 0), _defineProperty(_this11$localSearch$c, LEAF_CHILDREN, 0), _defineProperty(_this11$localSearch$c, LEAF_DESCENDANTS, 0), _this11$localSearch$c);\n        }\n      });\n      var lowerCasedSearchQuery = searchQuery.trim().toLocaleLowerCase();\n      var splitSearchQuery = lowerCasedSearchQuery.replace(/\\s+/g, " ").split(" ");\n      this.traverseAllNodesDFS(function (node) {\n        if (_this11.searchNested && splitSearchQuery.length > 1) {\n          node.isMatched = splitSearchQuery.every(function (filterValue) {\n            return match(false, filterValue, node.nestedSearchLabel);\n          });\n        } else {\n          node.isMatched = _this11.matchKeys.some(function (matchKey) {\n            return match(!_this11.disableFuzzyMatching, lowerCasedSearchQuery, node.lowerCased[matchKey]);\n          });\n        }\n        if (node.isMatched) {\n          _this11.localSearch.noResults = false;\n          node.ancestors.forEach(function (ancestor) {\n            return _this11.localSearch.countMap[ancestor.id][ALL_DESCENDANTS]++;\n          });\n          if (node.isLeaf) {\n            node.ancestors.forEach(function (ancestor) {\n              return _this11.localSearch.countMap[ancestor.id][LEAF_DESCENDANTS]++;\n            });\n          }\n          if (node.parentNode !== NO_PARENT_NODE) {\n            _this11.localSearch.countMap[node.parentNode.id][ALL_CHILDREN] += 1;\n            // istanbul ignore else\n            if (node.isLeaf) {\n              _this11.localSearch.countMap[node.parentNode.id][LEAF_CHILDREN] += 1;\n            }\n          }\n        }\n        if ((node.isMatched || node.isBranch && node.isExpandedOnSearch) && node.parentNode !== NO_PARENT_NODE) {\n          node.parentNode.isExpandedOnSearch = true;\n          node.parentNode.hasMatchedDescendants = true;\n        }\n      });\n      done();\n    },\n    handleRemoteSearch: function handleRemoteSearch() {\n      var _this12 = this;\n      var searchQuery = this.trigger.searchQuery;\n      var entry = this.getRemoteSearchEntry();\n      var done = function done() {\n        _this12.initialize();\n        _this12.resetHighlightedOptionWhenNecessary(true);\n        _this12.menu.renderKey++;\n      };\n      if ((searchQuery === "" || this.cacheOptions) && entry.isLoaded) {\n        return done();\n      }\n      this.callLoadOptionsProp({\n        action: ASYNC_SEARCH,\n        args: {\n          searchQuery: searchQuery\n        },\n        isPending: function isPending() {\n          return entry.isLoading;\n        },\n        start: function start() {\n          entry.isLoading = true;\n          entry.isLoaded = false;\n          entry.loadingError = "";\n        },\n        succeed: function succeed(options) {\n          entry.isLoaded = true;\n          entry.options = options;\n\n          // When the request completes, the search query may have changed.\n          // We only show these options if they are for the current search query.\n          if (_this12.trigger.searchQuery === searchQuery) {\n            done();\n          }\n          done();\n        },\n        fail: function fail(err) {\n          entry.loadingError = getErrorMessage(err);\n        },\n        end: function end() {\n          entry.isLoading = false;\n        }\n      });\n    },\n    getRemoteSearchEntry: function getRemoteSearchEntry() {\n      var _this13 = this;\n      var searchQuery = this.trigger.searchQuery;\n      var entry = this.remoteSearch[searchQuery] || _objectSpread(_objectSpread({}, createAsyncOptionsStates()), {}, {\n        options: []\n      });\n\n      // Vue doesn\'t support directly watching on objects.\n      this.$watch(function () {\n        return entry.options;\n      }, function () {\n        // TODO: potential redundant re-initialization.\n        if (_this13.trigger.searchQuery === searchQuery) {\n          _this13.initialize();\n        }\n      }, {\n        deep: true\n      });\n      if (searchQuery === "") {\n        if (Array.isArray(this.options)) {\n          entry.options = this.options;\n          entry.isLoaded = true;\n          return entry;\n        }\n      }\n      if (!this.remoteSearch[searchQuery]) {\n        this.remoteSearch[searchQuery] = entry;\n      }\n      return entry;\n    },\n    shouldExpand: function shouldExpand(node) {\n      return this.localSearch.active ? node.isExpandedOnSearch : node.isExpanded;\n    },\n    shouldOptionBeIncludedInSearchResult: function shouldOptionBeIncludedInSearchResult(node) {\n      // 1) This option is matched.\n      if (node.isMatched) {\n        return true;\n      }\n      // 2) This option is not matched, but has matched descendant(s).\n      if (node.isBranch && node.hasMatchedDescendants && !this.flattenSearchResults) {\n        return true;\n      }\n      // 3) This option\'s parent has no matched descendants,\n      //    but after being expanded, all its children should be shown.\n      if (!node.isRootNode && node.parentNode.showAllChildrenOnSearch) {\n        return true;\n      }\n      // 4) The default case.\n      return false;\n    },\n    shouldShowOptionInMenu: function shouldShowOptionInMenu(node) {\n      if (this.localSearch.active && !this.shouldOptionBeIncludedInSearchResult(node)) {\n        return false;\n      }\n      return true;\n    },\n    getControl: function getControl() {\n      return this.$refs.control.$el;\n    },\n    getMenu: function getMenu() {\n      var ref = this.appendToBody ? this.$refs.portal.portalTarget : this;\n      var $menu = ref.$refs.menu.$refs.menu;\n      return $menu && $menu.nodeName !== "#comment" ? $menu : null;\n    },\n    setCurrentHighlightedOption: function setCurrentHighlightedOption(node) {\n      var _this14 = this;\n      var scroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prev = this.menu.current;\n      if (prev != null && prev in this.forest.nodeMap) {\n        this.forest.nodeMap[prev].isHighlighted = false;\n      }\n      this.menu.current = node.id;\n      node.isHighlighted = true;\n      if (this.menu.isOpen && scroll) {\n        var scrollToOption = function scrollToOption() {\n          var $menu = _this14.getMenu();\n          var $option = $menu.querySelector(".vue3-treeselect__option[data-id=\\"".concat(node.id, "\\"]"));\n          if ($option) {\n            scrollIntoView($menu, $option);\n          }\n        };\n\n        // In case `openMenu()` is just called and the menu is not rendered yet.\n        if (this.getMenu()) {\n          scrollToOption();\n        } else {\n          // istanbul ignore next\n          this.$nextTick(scrollToOption);\n        }\n      }\n    },\n    resetHighlightedOptionWhenNecessary: function resetHighlightedOptionWhenNecessary() {\n      var forceReset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var current = this.menu.current;\n      if (forceReset || current == null || !(current in this.forest.nodeMap) || !this.shouldShowOptionInMenu(this.getNode(current))) {\n        this.highlightFirstOption();\n      }\n    },\n    highlightFirstOption: function highlightFirstOption() {\n      if (!this.hasVisibleOptions) {\n        return;\n      }\n      var first = this.visibleOptionIds[0];\n      this.setCurrentHighlightedOption(this.getNode(first));\n    },\n    highlightPrevOption: function highlightPrevOption() {\n      if (!this.hasVisibleOptions) {\n        return;\n      }\n      var prev = this.visibleOptionIds.indexOf(this.menu.current) - 1;\n      if (prev === -1) {\n        return this.highlightLastOption();\n      }\n      this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[prev]));\n    },\n    highlightNextOption: function highlightNextOption() {\n      if (!this.hasVisibleOptions) {\n        return;\n      }\n      var next = this.visibleOptionIds.indexOf(this.menu.current) + 1;\n      if (next === this.visibleOptionIds.length) {\n        return this.highlightFirstOption();\n      }\n      this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[next]));\n    },\n    highlightLastOption: function highlightLastOption() {\n      if (!this.hasVisibleOptions) {\n        return;\n      }\n      var last = last_default()(this.visibleOptionIds);\n      this.setCurrentHighlightedOption(this.getNode(last));\n    },\n    resetSearchQuery: function resetSearchQuery() {\n      this.trigger.searchQuery = "";\n    },\n    closeMenu: function closeMenu() {\n      if (!this.menu.isOpen || !this.disabled && this.alwaysOpen) {\n        return;\n      }\n      this.saveMenuScrollPosition();\n      this.menu.isOpen = false;\n      this.toggleClickOutsideEvent(false);\n      this.resetSearchQuery();\n      this.$emit("close", this.getValue(), this.getInstanceId());\n    },\n    openMenu: function openMenu() {\n      if (this.disabled || this.menu.isOpen) {\n        return;\n      }\n      this.menu.isOpen = true;\n      this.$nextTick(this.resetHighlightedOptionWhenNecessary);\n      this.$nextTick(this.restoreMenuScrollPosition);\n      if (!this.options) {\n        this.loadRootOptions();\n      }\n      this.toggleClickOutsideEvent(true);\n      this.$emit("open", this.getInstanceId());\n    },\n    toggleMenu: function toggleMenu() {\n      if (this.menu.isOpen) {\n        this.closeMenu();\n      } else {\n        this.openMenu();\n      }\n    },\n    toggleExpanded: function toggleExpanded(node) {\n      var nextState;\n      if (this.localSearch.active) {\n        nextState = node.isExpandedOnSearch = !node.isExpandedOnSearch;\n        if (nextState) {\n          node.showAllChildrenOnSearch = true;\n        }\n      } else {\n        nextState = node.isExpanded = !node.isExpanded;\n      }\n      if (nextState && !node.childrenStates.isLoaded) {\n        this.loadChildrenOptions(node);\n      }\n    },\n    buildForestState: function buildForestState() {\n      var _this15 = this;\n      var selectedNodeMap = createMap();\n      this.forest.selectedNodeIds.forEach(function (selectedNodeId) {\n        selectedNodeMap[selectedNodeId] = true;\n      });\n      this.forest.selectedNodeMap = selectedNodeMap;\n      var checkedStateMap = createMap();\n      if (this.multiple) {\n        this.traverseAllNodesByIndex(function (node) {\n          checkedStateMap[node.id] = UNCHECKED;\n        });\n        this.selectedNodes.forEach(function (selectedNode) {\n          checkedStateMap[selectedNode.id] = CHECKED;\n          if (!_this15.flat && !_this15.disableBranchNodes) {\n            selectedNode.ancestors.forEach(function (ancestorNode) {\n              if (!_this15.isSelected(ancestorNode)) {\n                checkedStateMap[ancestorNode.id] = INDETERMINATE;\n              }\n            });\n          }\n        });\n      }\n      this.forest.checkedStateMap = checkedStateMap;\n    },\n    enhancedNormalizer: function enhancedNormalizer(raw) {\n      return _objectSpread(_objectSpread({}, raw), this.normalizer(raw, this.getInstanceId()));\n    },\n    normalize: function normalize(parentNode, nodes, prevNodeMap) {\n      var _this16 = this;\n      var normalizedOptions = nodes.map(function (node) {\n        return [_this16.enhancedNormalizer(node), node];\n      }).map(function (_ref, index) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          node = _ref2[0],\n          raw = _ref2[1];\n        _this16.checkDuplication(node);\n        _this16.verifyNodeShape(node);\n        var id = node.id,\n          label = node.label,\n          children = node.children,\n          isDefaultExpanded = node.isDefaultExpanded;\n        var isRootNode = parentNode === NO_PARENT_NODE;\n        var level = isRootNode ? 0 : parentNode.level + 1;\n        var isBranch = Array.isArray(children) || children === null;\n        var isLeaf = !isBranch;\n        var isDisabled = !!node.isDisabled || !_this16.flat && !isRootNode && parentNode.isDisabled;\n        var isNew = !!node.isNew;\n        var lowerCased = _this16.matchKeys.reduce(function (prev, key) {\n          return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, key, stringifyOptionPropValue(node[key]).toLocaleLowerCase()));\n        }, {});\n        var nestedSearchLabel = isRootNode ? lowerCased.label : parentNode.nestedSearchLabel + " " + lowerCased.label;\n        _this16.forest.nodeMap[id] = createMap();\n        var normalized = _this16.forest.nodeMap[id];\n        normalized.id = id;\n        normalized.label = label;\n        normalized.level = level;\n        normalized.ancestors = isRootNode ? [] : [parentNode].concat(parentNode.ancestors);\n        normalized.index = (isRootNode ? [] : parentNode.index).concat(index);\n        normalized.parentNode = parentNode;\n        normalized.lowerCased = lowerCased;\n        normalized.nestedSearchLabel = nestedSearchLabel;\n        normalized.isDisabled = isDisabled;\n        normalized.isNew = isNew;\n        normalized.isMatched = false;\n        normalized.isHighlighted = false;\n        normalized.isBranch = isBranch;\n        normalized.isLeaf = isLeaf;\n        normalized.isRootNode = isRootNode;\n        normalized.raw = raw;\n        if (isBranch) {\n          var _normalized$count;\n          var isLoaded = Array.isArray(children);\n          normalized.childrenStates = _objectSpread(_objectSpread({}, createAsyncOptionsStates()), {}, {\n            isLoaded: isLoaded\n          });\n          normalized.isExpanded = typeof isDefaultExpanded === "boolean" ? isDefaultExpanded : level < _this16.defaultExpandLevel;\n          normalized.hasMatchedDescendants = false;\n          normalized.hasDisabledDescendants = false;\n          normalized.isExpandedOnSearch = false;\n          normalized.showAllChildrenOnSearch = false;\n          normalized.count = (_normalized$count = {}, _defineProperty(_normalized$count, ALL_CHILDREN, 0), _defineProperty(_normalized$count, ALL_DESCENDANTS, 0), _defineProperty(_normalized$count, LEAF_CHILDREN, 0), _defineProperty(_normalized$count, LEAF_DESCENDANTS, 0), _normalized$count);\n          normalized.children = isLoaded ? _this16.normalize(normalized, children, prevNodeMap) : [];\n          if (isDefaultExpanded === true) {\n            normalized.ancestors.forEach(function (ancestor) {\n              ancestor.isExpanded = true;\n            });\n          }\n          if (!isLoaded && typeof _this16.loadOptions !== "function") {\n            warning(function () {\n              return false;\n            }, function () {\n              return \'Unloaded branch node detected. "loadOptions" prop is required to load its children.\';\n            });\n          } else if (!isLoaded && normalized.isExpanded) {\n            _this16.loadChildrenOptions(normalized);\n          }\n        }\n        normalized.ancestors.forEach(function (ancestor) {\n          return ancestor.count[ALL_DESCENDANTS]++;\n        });\n        if (isLeaf) {\n          normalized.ancestors.forEach(function (ancestor) {\n            return ancestor.count[LEAF_DESCENDANTS]++;\n          });\n        }\n        if (!isRootNode) {\n          parentNode.count[ALL_CHILDREN] += 1;\n          if (isLeaf) {\n            parentNode.count[LEAF_CHILDREN] += 1;\n          }\n          if (isDisabled) {\n            parentNode.hasDisabledDescendants = true;\n          }\n        }\n\n        // Preserve previous states.\n        if (prevNodeMap && prevNodeMap[id]) {\n          var prev = prevNodeMap[id];\n          normalized.isMatched = prev.isMatched;\n          normalized.showAllChildrenOnSearch = prev.showAllChildrenOnSearch;\n          normalized.isHighlighted = prev.isHighlighted;\n          if (prev.isBranch && normalized.isBranch) {\n            normalized.isExpanded = prev.isExpanded;\n            normalized.isExpandedOnSearch = prev.isExpandedOnSearch;\n            // #97\n            // If `isLoaded` was true, but IS NOT now, we consider this branch node\n            // to be reset to unloaded state by the user of this component.\n            if (prev.childrenStates.isLoaded && !normalized.childrenStates.isLoaded) {\n              // Make sure the node is collapsed, then the user can load its\n              // children again (by expanding).\n              normalized.isExpanded = false;\n              // We have reset `childrenStates` and don\'t want to preserve states here.\n            } else {\n              normalized.childrenStates = _objectSpread({}, prev.childrenStates);\n            }\n          }\n        }\n        return normalized;\n      });\n      if (this.branchNodesFirst) {\n        var branchNodes = normalizedOptions.filter(function (option) {\n          return option.isBranch;\n        });\n        var leafNodes = normalizedOptions.filter(function (option) {\n          return option.isLeaf;\n        });\n        normalizedOptions = branchNodes.concat(leafNodes);\n      }\n      return normalizedOptions;\n    },\n    loadRootOptions: function loadRootOptions() {\n      var _this17 = this;\n      this.callLoadOptionsProp({\n        action: LOAD_ROOT_OPTIONS,\n        isPending: function isPending() {\n          return _this17.rootOptionsStates.isLoading;\n        },\n        start: function start() {\n          _this17.rootOptionsStates.isLoading = true;\n          _this17.rootOptionsStates.loadingError = "";\n        },\n        succeed: function succeed() {\n          _this17.rootOptionsStates.isLoaded = true;\n          // Wait for `options` being re-initialized.\n          _this17.$nextTick(function () {\n            _this17.resetHighlightedOptionWhenNecessary(true);\n          });\n        },\n        fail: function fail(err) {\n          _this17.rootOptionsStates.loadingError = getErrorMessage(err);\n        },\n        end: function end() {\n          _this17.rootOptionsStates.isLoading = false;\n        }\n      });\n    },\n    loadChildrenOptions: function loadChildrenOptions(parentNode) {\n      var _this18 = this;\n      // The options may be re-initialized anytime during the loading process.\n      // So `parentNode` can be stale and we use `getNode()` to avoid that.\n\n      var id = parentNode.id,\n        raw = parentNode.raw;\n      this.callLoadOptionsProp({\n        action: LOAD_CHILDREN_OPTIONS,\n        args: {\n          // We always pass the raw node instead of the normalized node to any\n          // callback provided by the user of this component.\n          // Because the shape of the raw node is more likely to be closing to\n          // what the back-end API service of the application needs.\n          parentNode: raw\n        },\n        isPending: function isPending() {\n          return _this18.getNode(id).childrenStates.isLoading;\n        },\n        start: function start() {\n          _this18.getNode(id).childrenStates.isLoading = true;\n          _this18.getNode(id).childrenStates.loadingError = "";\n        },\n        succeed: function succeed() {\n          _this18.getNode(id).childrenStates.isLoaded = true;\n        },\n        fail: function fail(err) {\n          _this18.getNode(id).childrenStates.loadingError = getErrorMessage(err);\n        },\n        end: function end() {\n          _this18.getNode(id).childrenStates.isLoading = false;\n        }\n      });\n    },\n    callLoadOptionsProp: function callLoadOptionsProp(_ref3) {\n      var action = _ref3.action,\n        args = _ref3.args,\n        isPending = _ref3.isPending,\n        start = _ref3.start,\n        succeed = _ref3.succeed,\n        fail = _ref3.fail,\n        end = _ref3.end;\n      if (!this.loadOptions || isPending()) {\n        return;\n      }\n      start();\n      var callback = once_default()(function (err, result) {\n        if (err) {\n          fail(err);\n        } else {\n          succeed(result);\n        }\n        end();\n      });\n      var result = this.loadOptions(_objectSpread(_objectSpread({\n        id: this.getInstanceId(),\n        instanceId: this.getInstanceId(),\n        action: action\n      }, args), {}, {\n        callback: callback\n      }));\n      if (external_is_promise_default()(result)) {\n        result.then(function () {\n          callback();\n        }, function (err) {\n          callback(err);\n        }).catch(function (err) {\n          // istanbul ignore next\n          console.error(err);\n        });\n      }\n    },\n    checkDuplication: function checkDuplication(node) {\n      var _this19 = this;\n      warning(function () {\n        return !(node.id in _this19.forest.nodeMap && !_this19.forest.nodeMap[node.id].isFallbackNode);\n      }, function () {\n        return "Detected duplicate presence of node id ".concat(JSON.stringify(node.id), ". ") + "Their labels are \\"".concat(_this19.forest.nodeMap[node.id].label, "\\" and \\"").concat(node.label, "\\" respectively.");\n      });\n    },\n    verifyNodeShape: function verifyNodeShape(node) {\n      warning(function () {\n        return !(node.children === undefined && node.isBranch === true);\n      }, function () {\n        return "Are you meant to declare an unloaded branch node? " + "`isBranch: true` is no longer supported, please use `children: null` instead.";\n      });\n    },\n    select: function select(node) {\n      if (this.disabled || node.isDisabled) {\n        return;\n      }\n      if (this.single) {\n        this.clear();\n      }\n      var nextState = this.multiple && !this.flat ? this.forest.checkedStateMap[node.id] === UNCHECKED : !this.isSelected(node);\n      if (nextState) {\n        this._selectNode(node);\n      } else {\n        this._deselectNode(node);\n      }\n      this.buildForestState();\n      if (nextState) {\n        this.$emit("select", node.raw, this.getInstanceId());\n      } else {\n        this.$emit("deselect", node.raw, this.getInstanceId());\n      }\n      if (this.localSearch.active && nextState && (this.single || this.clearOnSelect)) {\n        this.resetSearchQuery();\n      }\n      if (this.single && this.closeOnSelect) {\n        this.closeMenu();\n\n        // istanbul ignore else\n        if (this.searchable) {\n          this._blurOnSelect = true;\n        }\n      }\n    },\n    clear: function clear() {\n      var _this20 = this;\n      if (this.hasValue) {\n        if (this.single || this.allowClearingDisabled) {\n          this.forest.selectedNodeIds = [];\n        } /* if (this.multiple && !this.allowClearingDisabled) */else {\n          this.forest.selectedNodeIds = this.forest.selectedNodeIds.filter(function (nodeId) {\n            return _this20.getNode(nodeId).isDisabled;\n          });\n        }\n        this.buildForestState();\n      }\n    },\n    // This is meant to be called only by `select()`.\n    _selectNode: function _selectNode(node) {\n      var _this21 = this;\n      if (this.single || this.disableBranchNodes) {\n        return this.addValue(node);\n      }\n      if (this.flat) {\n        this.addValue(node);\n        if (this.autoSelectAncestors) {\n          node.ancestors.forEach(function (ancestor) {\n            if (!_this21.isSelected(ancestor) && !ancestor.isDisabled) {\n              _this21.addValue(ancestor);\n            }\n          });\n        } else if (this.autoSelectDescendants) {\n          this.traverseDescendantsBFS(node, function (descendant) {\n            if (!_this21.isSelected(descendant) && !descendant.isDisabled) {\n              _this21.addValue(descendant);\n            }\n          });\n        }\n        return;\n      }\n      var isFullyChecked = node.isLeaf || /* node.isBranch && */!node.hasDisabledDescendants || /* node.isBranch && */this.allowSelectingDisabledDescendants;\n      if (isFullyChecked) {\n        this.addValue(node);\n      }\n      if (node.isBranch) {\n        this.traverseDescendantsBFS(node, function (descendant) {\n          if (!descendant.isDisabled || _this21.allowSelectingDisabledDescendants) {\n            _this21.addValue(descendant);\n          }\n        });\n      }\n      if (isFullyChecked) {\n        var curr = node;\n        while ((curr = curr.parentNode) !== NO_PARENT_NODE) {\n          if (curr.children.every(this.isSelected)) {\n            this.addValue(curr);\n          } else {\n            break;\n          }\n        }\n      }\n    },\n    // This is meant to be called only by `select()`.\n    _deselectNode: function _deselectNode(node) {\n      var _this22 = this;\n      if (this.disableBranchNodes) {\n        return this.removeValue(node);\n      }\n      if (this.flat) {\n        this.removeValue(node);\n        if (this.autoDeselectAncestors) {\n          node.ancestors.forEach(function (ancestor) {\n            if (_this22.isSelected(ancestor) && !ancestor.isDisabled) {\n              _this22.removeValue(ancestor);\n            }\n          });\n        } else if (this.autoDeselectDescendants) {\n          this.traverseDescendantsBFS(node, function (descendant) {\n            if (_this22.isSelected(descendant) && !descendant.isDisabled) {\n              _this22.removeValue(descendant);\n            }\n          });\n        }\n        return;\n      }\n      var hasUncheckedSomeDescendants = false;\n      if (node.isBranch) {\n        this.traverseDescendantsDFS(node, function (descendant) {\n          if (!descendant.isDisabled || _this22.allowSelectingDisabledDescendants) {\n            _this22.removeValue(descendant);\n            hasUncheckedSomeDescendants = true;\n          }\n        });\n      }\n      if (node.isLeaf || /* node.isBranch && */hasUncheckedSomeDescendants || /* node.isBranch && */node.children.length === 0) {\n        this.removeValue(node);\n        var curr = node;\n        while ((curr = curr.parentNode) !== NO_PARENT_NODE) {\n          if (this.isSelected(curr)) {\n            this.removeValue(curr);\n          } else {\n            break;\n          }\n        }\n      }\n    },\n    addValue: function addValue(node) {\n      this.forest.selectedNodeIds.push(node.id);\n      this.forest.selectedNodeMap[node.id] = true;\n    },\n    removeValue: function removeValue(node) {\n      removeFromArray(this.forest.selectedNodeIds, node.id);\n      delete this.forest.selectedNodeMap[node.id];\n    },\n    removeLastValue: function removeLastValue() {\n      if (!this.hasValue) {\n        return;\n      }\n      if (this.single) {\n        return this.clear();\n      }\n      var lastValue = last_default()(this.internalValue);\n      var lastSelectedNode = this.getNode(lastValue);\n      this.select(lastSelectedNode); // deselect\n    },\n    saveMenuScrollPosition: function saveMenuScrollPosition() {\n      var $menu = this.getMenu();\n      // istanbul ignore else\n      if ($menu) {\n        this.menu.lastScrollPosition = $menu.scrollTop;\n      }\n    },\n    restoreMenuScrollPosition: function restoreMenuScrollPosition() {\n      var $menu = this.getMenu();\n      // istanbul ignore else\n      if ($menu) {\n        $menu.scrollTop = this.menu.lastScrollPosition;\n      }\n    }\n  },\n  created: function created() {\n    this.verifyProps();\n    this.resetFlags();\n  },\n  mounted: function mounted() {\n    if (this.autoFocus) {\n      this.focusInput();\n    }\n    if (!this.options && this.autoLoadRootOptions) {\n      this.loadRootOptions();\n    }\n    if (this.alwaysOpen) {\n      this.openMenu();\n    }\n  },\n  unmounted: function unmounted() {\n    // istanbul ignore next\n    this.toggleClickOutsideEvent(false);\n  }\n});\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/HiddenFields.vue?vue&type=script&lang=jsx\n\n\n\nfunction stringifyValue(value) {\n  if (typeof value === "string") {\n    return value;\n  }\n  // istanbul ignore else\n  if (value != null && !isNaN_isNaN(value)) {\n    return JSON.stringify(value);\n  }\n  // istanbul ignore next\n  return "";\n}\n/* harmony default export */ var HiddenFieldsvue_type_script_lang_jsx = ((0,external_vue_namespaceObject.defineComponent)({\n  name: "vue3-treeselect--hidden-fields",\n  functional: true,\n  inject: ["instance"],\n  render: function render(context) {\n    var instance = context.instance;\n    if (!instance.name || instance.disabled || !instance.hasValue) {\n      return null;\n    }\n    var stringifiedValues = instance.internalValue.map(stringifyValue);\n    if (instance.multiple && instance.joinValues) {\n      stringifiedValues = [stringifiedValues.join(instance.delimiter)];\n    }\n    return stringifiedValues.map(function (stringifiedValue, i) {\n      return (0,external_vue_namespaceObject.createVNode)("input", {\n        "type": "hidden",\n        "name": instance.name,\n        "value": stringifiedValue,\n        "key": "hidden-field-" + i\n      }, null);\n    });\n  }\n}));\n;// CONCATENATED MODULE: ./src/components/HiddenFields.vue?vue&type=script&lang=jsx\n \n// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js\nvar exportHelper = __webpack_require__("./node_modules/vue-loader/dist/exportHelper.js");\n;// CONCATENATED MODULE: ./src/components/HiddenFields.vue\n\n\n\n;\nconst __exports__ = /*#__PURE__*/(0,exportHelper["default"])(HiddenFieldsvue_type_script_lang_jsx, [[\'__file\',"src/components/HiddenFields.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var HiddenFields = (__exports__);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Input.vue?vue&type=script&lang=jsx\n\n\n\nvar keysThatRequireMenuBeingOpen = [KEY_CODES.ENTER, KEY_CODES.END, KEY_CODES.HOME, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN];\n/* harmony default export */ var Inputvue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--input",\n  inject: ["instance"],\n  data: function data() {\n    return {\n      inputWidth: MIN_INPUT_WIDTH,\n      value: ""\n    };\n  },\n  computed: {\n    needAutoSize: function needAutoSize() {\n      var instance = this.instance;\n      return instance.searchable && !instance.disabled && instance.multiple;\n    },\n    inputStyle: function inputStyle() {\n      return {\n        width: this.needAutoSize ? "".concat(this.inputWidth, "px") : null\n      };\n    }\n  },\n  watch: {\n    "instance.trigger.searchQuery": function instanceTriggerSearchQuery(newValue) {\n      this.value = newValue;\n    },\n    value: function value() {\n      // istanbul ignore else\n      if (this.needAutoSize) {\n        this.$nextTick(this.updateInputWidth);\n      }\n    }\n  },\n  created: function created() {\n    this.debouncedCallback = debounce_default()(this.updateSearchQuery, INPUT_DEBOUNCE_DELAY, {\n      leading: true,\n      trailing: true\n    });\n  },\n  methods: {\n    clear: function clear() {\n      this.onInput({\n        target: {\n          value: ""\n        }\n      });\n    },\n    focus: function focus() {\n      var instance = this.instance;\n      if (!instance.disabled) {\n        this.$refs.input && this.$refs.input.focus();\n      }\n    },\n    blur: function blur() {\n      this.$refs.input && this.$refs.input.blur();\n    },\n    onFocus: function onFocus() {\n      var instance = this.instance;\n      instance.trigger.isFocused = true;\n      // istanbul ignore else\n      if (instance.openOnFocus) {\n        instance.openMenu();\n      }\n    },\n    onBlur: function onBlur() {\n      var instance = this.instance;\n      var menu = instance.getMenu();\n\n      // #15\n      // istanbul ignore next\n      if (menu && document.activeElement === menu) {\n        return this.focus();\n      }\n      instance.trigger.isFocused = false;\n      instance.closeMenu();\n    },\n    onInput: function onInput(evt) {\n      var value = evt.target.value;\n      this.value = value;\n      if (value) {\n        this.debouncedCallback();\n      } else {\n        this.debouncedCallback.cancel();\n        this.updateSearchQuery();\n      }\n    },\n    // 用 keyUp 事件存在一个问题，删除输入框最后一个字符也会导致取消选中最后一项\n    onKeyDown: function onKeyDown(evt) {\n      var instance = this.instance;\n      // https://css-tricks.com/snippets/javascript/javascript-keycodes/\n      // https://stackoverflow.com/questions/4471582/javascript-keycode-vs-which\n      var key = "which" in evt ? evt.which : /* istanbul ignore next */evt.keyCode;\n      if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey) {\n        return;\n      }\n      if (!instance.menu.isOpen && includes(keysThatRequireMenuBeingOpen, key)) {\n        evt.preventDefault();\n        return instance.openMenu();\n      }\n      switch (key) {\n        case KEY_CODES.BACKSPACE:\n          {\n            if (instance.backspaceRemoves && !this.value.length) {\n              instance.removeLastValue();\n            }\n            break;\n          }\n        case KEY_CODES.ENTER:\n          {\n            evt.preventDefault();\n            if (instance.menu.current === null) {\n              return;\n            }\n            var current = instance.getNode(instance.menu.current);\n            if (current.isBranch && instance.disableBranchNodes || !current.isMatched) {\n              return;\n            }\n            instance.select(current);\n            break;\n          }\n        case KEY_CODES.ESCAPE:\n          {\n            if (this.value.length) {\n              this.clear();\n            } else if (instance.menu.isOpen) {\n              instance.closeMenu();\n            }\n            break;\n          }\n        case KEY_CODES.END:\n          {\n            evt.preventDefault();\n            instance.highlightLastOption();\n            break;\n          }\n        case KEY_CODES.HOME:\n          {\n            evt.preventDefault();\n            instance.highlightFirstOption();\n            break;\n          }\n        case KEY_CODES.ARROW_LEFT:\n          {\n            var _current = instance.getNode(instance.menu.current);\n            if (_current.isBranch && instance.shouldExpand(_current)) {\n              evt.preventDefault();\n              instance.toggleExpanded(_current);\n            } else if (!_current.isRootNode && (_current.isLeaf || _current.isBranch && !instance.shouldExpand(_current))) {\n              evt.preventDefault();\n              instance.setCurrentHighlightedOption(_current.parentNode);\n            }\n            break;\n          }\n        case KEY_CODES.ARROW_UP:\n          {\n            evt.preventDefault();\n            instance.highlightPrevOption();\n            break;\n          }\n        case KEY_CODES.ARROW_RIGHT:\n          {\n            var _current2 = instance.getNode(instance.menu.current);\n            if (_current2.isBranch && !instance.shouldExpand(_current2)) {\n              evt.preventDefault();\n              instance.toggleExpanded(_current2);\n            }\n            break;\n          }\n        case KEY_CODES.ARROW_DOWN:\n          {\n            evt.preventDefault();\n            instance.highlightNextOption();\n            break;\n          }\n        case KEY_CODES.DELETE:\n          {\n            if (instance.deleteRemoves && !this.value.length) {\n              instance.removeLastValue();\n            }\n            break;\n          }\n        default:\n          {\n            // istanbul ignore else\n            instance.openMenu();\n          }\n      }\n    },\n    onMouseDown: function onMouseDown(evt) {\n      // istanbul ignore next\n      if (this.value.length) {\n        // Prevent it from bubbling to the top level and triggering `preventDefault()`\n        // to make the textbox unselectable\n        evt.stopPropagation();\n      }\n    },\n    renderInputContainer: function renderInputContainer() {\n      var instance = this.instance;\n      var props = {};\n      var children = [];\n      if (instance.searchable && !instance.disabled) {\n        children.push(this.renderInput());\n        if (this.needAutoSize) {\n          children.push(this.renderSizer());\n        }\n      }\n      if (!instance.searchable) {\n        deepExtend(props, {\n          on: {\n            focus: this.onFocus,\n            blur: this.onBlur,\n            keydown: this.onKeyDown\n          },\n          ref: "input"\n        });\n      }\n      if (!instance.searchable && !instance.disabled) {\n        deepExtend(props, {\n          attrs: {\n            tabIndex: instance.tabIndex\n          }\n        });\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", (0,external_vue_namespaceObject.mergeProps)({\n        "class": "vue3-treeselect__input-container"\n      }, props), [children]);\n    },\n    renderInput: function renderInput() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)("input", {\n        "ref": "input",\n        "class": "vue3-treeselect__input",\n        "type": "text",\n        "autocomplete": "off",\n        "tabIndex": instance.tabIndex,\n        "required": instance.required && !instance.hasValue,\n        "value": this.value,\n        "style": this.inputStyle,\n        "onFocus": this.onFocus,\n        "onInput": this.onInput,\n        "onBlur": this.onBlur,\n        "onKeydown": this.onKeyDown,\n        "onMousedown": this.onMouseDown\n      }, null);\n    },\n    renderSizer: function renderSizer() {\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "ref": "sizer",\n        "class": "vue3-treeselect__sizer"\n      }, [this.value]);\n    },\n    updateInputWidth: function updateInputWidth() {\n      this.inputWidth = Math.max(MIN_INPUT_WIDTH, this.$refs.sizer.scrollWidth + 15);\n    },\n    updateSearchQuery: function updateSearchQuery() {\n      var instance = this.instance;\n      instance.trigger.searchQuery = this.value;\n    }\n  },\n  render: function render() {\n    return this.renderInputContainer();\n  }\n});\n;// CONCATENATED MODULE: ./src/components/Input.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Input.vue\n\n\n\n;\nconst Input_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Inputvue_type_script_lang_jsx, [[\'__file\',"src/components/Input.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Input = (Input_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Placeholder.vue?vue&type=script&lang=jsx\n\n/* harmony default export */ var Placeholdervue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--placeholder",\n  inject: ["instance"],\n  render: function render() {\n    var instance = this.instance;\n    var placeholderClass = {\n      "vue3-treeselect__placeholder": true,\n      "vue3-treeselect-helper-zoom-effect-off": true,\n      "vue3-treeselect-helper-hide": instance.hasValue || instance.trigger.searchQuery\n    };\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": placeholderClass\n    }, [instance.placeholder]);\n  }\n});\n;// CONCATENATED MODULE: ./src/components/Placeholder.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Placeholder.vue\n\n\n\n;\nconst Placeholder_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Placeholdervue_type_script_lang_jsx, [[\'__file\',"src/components/Placeholder.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Placeholder = (Placeholder_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/SingleValue.vue?vue&type=script&lang=jsx\n\n\n\n/* harmony default export */ var SingleValuevue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--single-value",\n  inject: ["instance"],\n  methods: {\n    renderSingleValueLabel: function renderSingleValueLabel() {\n      var instance = this.instance;\n      var node = instance.selectedNodes[0];\n      var customValueLabelRenderer = instance.$slots["value-label"];\n      return customValueLabelRenderer ? customValueLabelRenderer({\n        node: node\n      }) : node.label;\n    }\n  },\n  render: function render() {\n    var instance = this.instance,\n      renderValueContainer = this.$parent.renderValueContainer;\n    var shouldShowValue = instance.hasValue && !instance.trigger.searchQuery;\n    return renderValueContainer([shouldShowValue && (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "vue3-treeselect__single-value"\n    }, [this.renderSingleValueLabel()]), (0,external_vue_namespaceObject.createVNode)(Placeholder, null, null), (0,external_vue_namespaceObject.createVNode)(Input, {\n      "ref": "input"\n    }, null)]);\n  }\n});\n;// CONCATENATED MODULE: ./src/components/SingleValue.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/SingleValue.vue\n\n\n\n;\nconst SingleValue_exports_ = /*#__PURE__*/(0,exportHelper["default"])(SingleValuevue_type_script_lang_jsx, [[\'__file\',"src/components/SingleValue.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var SingleValue = (SingleValue_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/icons/Delete.vue?vue&type=template&id=364b6320\n\nvar _hoisted_1 = {\n  xmlns: "http://www.w3.org/2000/svg",\n  viewBox: "0 0 348.333 348.333"\n};\nvar _hoisted_2 = /*#__PURE__*/(0,external_vue_namespaceObject.createElementVNode)("path", {\n  d: "M336.559 68.611L231.016 174.165l105.543 105.549c15.699 15.705 15.699 41.145 0 56.85-7.844 7.844-18.128 11.769-28.407 11.769-10.296 0-20.581-3.919-28.419-11.769L174.167 231.003 68.609 336.563c-7.843 7.844-18.128 11.769-28.416 11.769-10.285 0-20.563-3.919-28.413-11.769-15.699-15.698-15.699-41.139 0-56.85l105.54-105.549L11.774 68.611c-15.699-15.699-15.699-41.145 0-56.844 15.696-15.687 41.127-15.687 56.829 0l105.563 105.554L279.721 11.767c15.705-15.687 41.139-15.687 56.832 0 15.705 15.699 15.705 41.145.006 56.844z"\n}, null, -1 /* HOISTED */);\nvar _hoisted_3 = [_hoisted_2];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,external_vue_namespaceObject.openBlock)(), (0,external_vue_namespaceObject.createElementBlock)("svg", _hoisted_1, _hoisted_3);\n}\n;// CONCATENATED MODULE: ./src/components/icons/Delete.vue?vue&type=template&id=364b6320\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/icons/Delete.vue?vue&type=script&lang=js\n/* harmony default export */ var Deletevue_type_script_lang_js = ({\n  name: "vue3-treeselect--x"\n});\n;// CONCATENATED MODULE: ./src/components/icons/Delete.vue?vue&type=script&lang=js\n \n;// CONCATENATED MODULE: ./src/components/icons/Delete.vue\n\n\n\n\n;\nconst Delete_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Deletevue_type_script_lang_js, [[\'render\',render],[\'__file\',"src/components/icons/Delete.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Delete = (Delete_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/MultiValueItem.vue?vue&type=script&lang=jsx\n\n\n\n/* harmony default export */ var MultiValueItemvue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--multi-value-item",\n  inject: ["instance"],\n  props: {\n    node: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    handleMouseDown: onLeftClick(function handleMouseDown() {\n      var instance = this.instance,\n        node = this.node;\n\n      // Deselect this node.\n      instance.select(node);\n    })\n  },\n  render: function render() {\n    var instance = this.instance,\n      node = this.node;\n    var itemClass = {\n      "vue3-treeselect__multi-value-item": true,\n      "vue3-treeselect__multi-value-item-disabled": node.isDisabled,\n      "vue3-treeselect__multi-value-item-new": node.isNew\n    };\n    var customValueLabelRenderer = instance.$slots["value-label"];\n    var labelRenderer = customValueLabelRenderer ? customValueLabelRenderer({\n      node: node\n    }) : node.label;\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "vue3-treeselect__multi-value-item-container"\n    }, [(0,external_vue_namespaceObject.createVNode)("div", {\n      "class": itemClass\n    }, [(0,external_vue_namespaceObject.createVNode)("span", {\n      "class": "vue3-treeselect__multi-value-label"\n    }, [labelRenderer]), (0,external_vue_namespaceObject.createVNode)("span", {\n      "class": "vue3-treeselect__icon vue3-treeselect__value-remove",\n      "onMousedown": this.handleMouseDown\n    }, [(0,external_vue_namespaceObject.createVNode)(Delete, null, null)])])]);\n  }\n});\n;// CONCATENATED MODULE: ./src/components/MultiValueItem.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/MultiValueItem.vue\n\n\n\n;\nconst MultiValueItem_exports_ = /*#__PURE__*/(0,exportHelper["default"])(MultiValueItemvue_type_script_lang_jsx, [[\'__file\',"src/components/MultiValueItem.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var MultiValueItem = (MultiValueItem_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/MultiValue.vue?vue&type=script&lang=jsx\n\n\n\n\n/* harmony default export */ var MultiValuevue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--multi-value",\n  inject: ["instance"],\n  methods: {\n    renderMultiValueItems: function renderMultiValueItems() {\n      var instance = this.instance;\n      return instance.internalValue.slice(0, instance.limit).map(instance.getNode).map(function (node) {\n        return (0,external_vue_namespaceObject.createVNode)(MultiValueItem, {\n          "key": "multi-value-item-".concat(node.id),\n          "node": node\n        }, null);\n      });\n    },\n    renderExceedLimitTip: function renderExceedLimitTip() {\n      var instance = this.instance;\n      var count = instance.internalValue.length - instance.limit;\n      if (count <= 0) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__limit-tip vue3-treeselect-helper-zoom-effect-off",\n        "key": "exceed-limit-tip"\n      }, [(0,external_vue_namespaceObject.createVNode)("span", {\n        "class": "vue3-treeselect__limit-tip-text"\n      }, [instance.limitText(count)])]);\n    }\n  },\n  render: function render() {\n    var _this = this;\n    var renderValueContainer = this.$parent.renderValueContainer;\n    return renderValueContainer((0,external_vue_namespaceObject.createVNode)(TransitionGroup, {\n      "class": "vue3-treeselect__multi-value",\n      "tag": "div",\n      "name": "vue3-treeselect__multi-value-item--transition",\n      "appear": true\n    }, {\n      default: function _default() {\n        return [_this.renderMultiValueItems(), _this.renderExceedLimitTip(), (0,external_vue_namespaceObject.createVNode)(Placeholder, {\n          "key": "placeholder"\n        }, null), (0,external_vue_namespaceObject.createVNode)(Input, {\n          "ref": "input",\n          "key": "input"\n        }, null)];\n      }\n    }));\n  }\n});\n;// CONCATENATED MODULE: ./src/components/MultiValue.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/MultiValue.vue\n\n\n\n;\nconst MultiValue_exports_ = /*#__PURE__*/(0,exportHelper["default"])(MultiValuevue_type_script_lang_jsx, [[\'__file\',"src/components/MultiValue.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var MultiValue = (MultiValue_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/icons/Arrow.vue?vue&type=template&id=11186cd4\n\nvar Arrowvue_type_template_id_11186cd4_hoisted_1 = {\n  xmlns: "http://www.w3.org/2000/svg",\n  viewBox: "0 0 292.362 292.362"\n};\nvar Arrowvue_type_template_id_11186cd4_hoisted_2 = /*#__PURE__*/(0,external_vue_namespaceObject.createElementVNode)("path", {\n  d: "M286.935 69.377c-3.614-3.617-7.898-5.424-12.848-5.424H18.274c-4.952 0-9.233 1.807-12.85 5.424C1.807 72.998 0 77.279 0 82.228c0 4.948 1.807 9.229 5.424 12.847l127.907 127.907c3.621 3.617 7.902 5.428 12.85 5.428s9.233-1.811 12.847-5.428L286.935 95.074c3.613-3.617 5.427-7.898 5.427-12.847 0-4.948-1.814-9.229-5.427-12.85z"\n}, null, -1 /* HOISTED */);\nvar Arrowvue_type_template_id_11186cd4_hoisted_3 = [Arrowvue_type_template_id_11186cd4_hoisted_2];\nfunction Arrowvue_type_template_id_11186cd4_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,external_vue_namespaceObject.openBlock)(), (0,external_vue_namespaceObject.createElementBlock)("svg", Arrowvue_type_template_id_11186cd4_hoisted_1, Arrowvue_type_template_id_11186cd4_hoisted_3);\n}\n;// CONCATENATED MODULE: ./src/components/icons/Arrow.vue?vue&type=template&id=11186cd4\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/icons/Arrow.vue?vue&type=script&lang=js\n/* harmony default export */ var Arrowvue_type_script_lang_js = ({\n  name: "vue3-treeselect--arrow"\n});\n;// CONCATENATED MODULE: ./src/components/icons/Arrow.vue?vue&type=script&lang=js\n \n;// CONCATENATED MODULE: ./src/components/icons/Arrow.vue\n\n\n\n\n;\nconst Arrow_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Arrowvue_type_script_lang_js, [[\'render\',Arrowvue_type_template_id_11186cd4_render],[\'__file\',"src/components/icons/Arrow.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Arrow = (Arrow_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Control.vue?vue&type=script&lang=jsx\n\n\n\n\n\n\n/* harmony default export */ var Controlvue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--control",\n  inject: ["instance"],\n  computed: {\n    /* eslint-disable valid-jsdoc */\n    /**\r\n     * Should show the "×" button that resets value?\r\n     * @return {boolean}\r\n     */\n    shouldShowX: function shouldShowX() {\n      var instance = this.instance;\n      return instance.clearable && !instance.disabled && instance.hasValue && (this.hasUndisabledValue || instance.allowClearingDisabled);\n    },\n    /**\r\n     * Should show the arrow button that toggles menu?\r\n     * @return {boolean}\r\n     */\n    shouldShowArrow: function shouldShowArrow() {\n      var instance = this.instance;\n      if (!instance.alwaysOpen) {\n        return true;\n      }\n      // Even with `alwaysOpen: true`, sometimes the menu is still closed,\n      // e.g. when the control is disabled.\n      return !instance.menu.isOpen;\n    },\n    /**\r\n     * Has any undisabled option been selected?\r\n     * @type {boolean}\r\n     */\n    hasUndisabledValue: function hasUndisabledValue() {\n      var instance = this.instance;\n      return instance.hasValue && instance.internalValue.some(function (id) {\n        return !instance.getNode(id).isDisabled;\n      });\n    } /* eslint-enable valid-jsdoc */\n  },\n  methods: {\n    renderX: function renderX() {\n      var instance = this.instance;\n      var title = instance.multiple ? instance.clearAllText : instance.clearValueText;\n      if (!this.shouldShowX) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__x-container",\n        "title": title,\n        "onMousedown": this.handleMouseDownOnX\n      }, [(0,external_vue_namespaceObject.createVNode)(Delete, {\n        "class": "vue3-treeselect__x"\n      }, null)]);\n    },\n    renderArrow: function renderArrow() {\n      var instance = this.instance;\n      var arrowClass = {\n        "vue3-treeselect__control-arrow": true,\n        "vue3-treeselect__control-arrow--rotated": instance.menu.isOpen\n      };\n      if (!this.shouldShowArrow) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__control-arrow-container",\n        "onMousedown": this.handleMouseDownOnArrow\n      }, [(0,external_vue_namespaceObject.createVNode)(Arrow, {\n        "class": arrowClass\n      }, null)]);\n    },\n    handleMouseDownOnX: onLeftClick(function handleMouseDownOnX(evt) {\n      /**\r\n       * We don\'t use async/await here because we don\'t want\r\n       * to rely on Babel polyfill or regenerator runtime.\r\n       * See: https://babeljs.io/docs/plugins/transform-regenerator/\r\n       * We also don\'t want to assume there is a global `Promise`\r\n       * class, since we are targeting to support IE9 without the\r\n       * need of any polyfill.\r\n       */\n\n      evt.stopPropagation();\n      evt.preventDefault();\n      var instance = this.instance;\n      var result = instance.beforeClearAll();\n      var handler = function handler(shouldClear) {\n        if (shouldClear) {\n          instance.clear();\n        }\n      };\n      if (external_is_promise_default()(result)) {\n        // The handler will be called async.\n        result.then(handler);\n      } else {\n        // Keep the same behavior here.\n        setTimeout(function () {\n          return handler(result);\n        }, 0);\n        // Also, note that IE9 requires:\n        //   setTimeout(() => fn(...args), delay)\n        // Instead of:\n        //   setTimeout(fn, delay, ...args)\n      }\n    }),\n    handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnArrow(evt) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      var instance = this.instance;\n\n      // Focus the input or prevent blurring.\n      instance.focusInput();\n      instance.toggleMenu();\n    }),\n    // This is meant to be called by child `<Value />` component.\n    renderValueContainer: function renderValueContainer(children) {\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__value-container"\n      }, [children]);\n    }\n  },\n  render: function render() {\n    var instance = this.instance;\n    var ValueContainer = instance.single ? SingleValue : MultiValue;\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "vue3-treeselect__control",\n      "onMousedown": instance.handleMouseDown\n    }, [(0,external_vue_namespaceObject.createVNode)(ValueContainer, {\n      "ref": "value-container"\n    }, null), this.renderX(), this.renderArrow()]);\n  }\n});\n;// CONCATENATED MODULE: ./src/components/Control.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Control.vue\n\n\n\n;\nconst Control_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Controlvue_type_script_lang_jsx, [[\'__file\',"src/components/Control.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Control = (Control_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Tip.vue?vue&type=script&lang=jsx\n\n/* harmony default export */ var Tipvue_type_script_lang_jsx = (defineComponent({\n  name: "vue3-treeselect--tip",\n  functional: true,\n  props: {\n    type: {\n      type: String,\n      required: true\n    },\n    icon: {\n      type: String,\n      required: true\n    }\n  },\n  render: function render() {\n    var type = this.type,\n      icon = this.icon;\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "vue3-treeselect__tip vue3-treeselect__".concat(type, "-tip")\n    }, [(0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "vue3-treeselect__icon-container"\n    }, [(0,external_vue_namespaceObject.createVNode)("span", {\n      "class": "vue3-treeselect__icon-".concat(icon)\n    }, null)]), (0,external_vue_namespaceObject.createVNode)("span", {\n      "class": "vue3-treeselect__tip-text vue3-treeselect__".concat(type, "-tip-text")\n    }, [this.$slots.default()])]);\n  }\n}));\n;// CONCATENATED MODULE: ./src/components/Tip.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Tip.vue\n\n\n\n;\nconst Tip_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Tipvue_type_script_lang_jsx, [[\'__file\',"src/components/Tip.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Tip = (Tip_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Option.vue?vue&type=script&lang=jsx\n\nfunction Optionvue_type_script_lang_jsx_typeof(o) { "@babel/helpers - typeof"; return Optionvue_type_script_lang_jsx_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Optionvue_type_script_lang_jsx_typeof(o); }\nfunction Optionvue_type_script_lang_jsx_defineProperty(obj, key, value) { key = Optionvue_type_script_lang_jsx_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction Optionvue_type_script_lang_jsx_toPropertyKey(arg) { var key = Optionvue_type_script_lang_jsx_toPrimitive(arg, "string"); return Optionvue_type_script_lang_jsx_typeof(key) === "symbol" ? key : String(key); }\nfunction Optionvue_type_script_lang_jsx_toPrimitive(input, hint) { if (Optionvue_type_script_lang_jsx_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (Optionvue_type_script_lang_jsx_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\nfunction _isSlot(s) {\n  return typeof s === \'function\' || Object.prototype.toString.call(s) === \'[object Object]\' && !(0,external_vue_namespaceObject.isVNode)(s);\n}\nvar arrowPlaceholder, checkMark, minusMark;\nvar Option = {\n  name: "vue3-treeselect--option",\n  inject: ["instance"],\n  props: {\n    node: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    shouldExpand: function shouldExpand() {\n      var instance = this.instance,\n        node = this.node;\n      return node.isBranch && instance.shouldExpand(node);\n    },\n    shouldShow: function shouldShow() {\n      var instance = this.instance,\n        node = this.node;\n      return instance.shouldShowOptionInMenu(node);\n    }\n  },\n  methods: {\n    renderOption: function renderOption() {\n      var instance = this.instance,\n        node = this.node;\n      var optionClass = {\n        "vue3-treeselect__option": true,\n        "vue3-treeselect__option--disabled": node.isDisabled,\n        "vue3-treeselect__option--selected": instance.isSelected(node),\n        "vue3-treeselect__option--highlight": node.isHighlighted,\n        "vue3-treeselect__option--matched": instance.localSearch.active && node.isMatched,\n        "vue3-treeselect__option--hide": !this.shouldShow\n      };\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": optionClass,\n        "onMouseenter": this.handleMouseEnterOption,\n        "data-id": node.id\n      }, [this.renderArrow(), this.renderLabelContainer([this.renderCheckboxContainer([this.renderCheckbox()]), this.renderLabel()])]);\n    },\n    renderSubOptionsList: function renderSubOptionsList() {\n      if (!this.shouldExpand) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__list"\n      }, [this.renderSubOptions(), this.renderNoChildrenTip(), this.renderLoadingChildrenTip(), this.renderLoadingChildrenErrorTip()]);\n    },\n    renderArrow: function renderArrow() {\n      var instance = this.instance,\n        node = this.node;\n      if (instance.shouldFlattenOptions && this.shouldShow) {\n        return null;\n      }\n      if (node.isBranch) {\n        var arrowClass = {\n          "vue3-treeselect__option-arrow": true,\n          "vue3-treeselect__option-arrow--rotated": this.shouldExpand\n        };\n        return (0,external_vue_namespaceObject.createVNode)("div", {\n          "class": "vue3-treeselect__option-arrow-container",\n          "onMousedown": this.handleMouseDownOnArrow\n        }, [(0,external_vue_namespaceObject.createVNode)(Transition, {\n          "name": "vue3-treeselect__option-arrow--prepare",\n          "appear": true\n        }, {\n          default: function _default() {\n            return [(0,external_vue_namespaceObject.createVNode)(Arrow, {\n              "class": arrowClass\n            }, null)];\n          }\n        })]);\n      }\n\n      // For leaf nodes, we render a placeholder to keep its label aligned to\n      // branch nodes. Unless there is no branch nodes at all (a normal\n      // non-tree select).\n      if ( /*node.isLeaf && */instance.hasBranchNodes) {\n        if (!arrowPlaceholder) {\n          arrowPlaceholder = (0,external_vue_namespaceObject.createVNode)("div", {\n            "class": "vue3-treeselect__option-arrow-placeholder"\n          }, [(0,external_vue_namespaceObject.createTextVNode)("\\xA0")]);\n        }\n        return arrowPlaceholder;\n      }\n      return null;\n    },\n    renderLabelContainer: function renderLabelContainer(children) {\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__label-container",\n        "onMousedown": this.handleMouseDownOnLabelContainer\n      }, [children]);\n    },\n    renderCheckboxContainer: function renderCheckboxContainer(children) {\n      var instance = this.instance,\n        node = this.node;\n      if (instance.single) {\n        return null;\n      }\n      if (instance.disableBranchNodes && node.isBranch) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__checkbox-container"\n      }, [children]);\n    },\n    renderCheckbox: function renderCheckbox() {\n      var instance = this.instance,\n        node = this.node;\n      var checkedState = instance.forest.checkedStateMap[node.id];\n      var checkboxClass = {\n        "vue3-treeselect__checkbox": true,\n        "vue3-treeselect__checkbox--checked": checkedState === CHECKED,\n        "vue3-treeselect__checkbox--indeterminate": checkedState === INDETERMINATE,\n        "vue3-treeselect__checkbox--unchecked": checkedState === UNCHECKED,\n        "vue3-treeselect__checkbox--disabled": node.isDisabled\n      };\n      if (!checkMark) {\n        checkMark = (0,external_vue_namespaceObject.createVNode)("span", {\n          "class": "vue3-treeselect__check-mark"\n        }, null);\n      }\n      if (!minusMark) {\n        minusMark = (0,external_vue_namespaceObject.createVNode)("span", {\n          "class": "vue3-treeselect__minus-mark"\n        }, null);\n      }\n      return (0,external_vue_namespaceObject.createVNode)("span", {\n        "class": checkboxClass\n      }, [checkMark, minusMark]);\n    },\n    renderLabel: function renderLabel() {\n      var instance = this.instance,\n        node = this.node;\n      var shouldShowCount = node.isBranch && (instance.localSearch.active ? instance.showCountOnSearchComputed : instance.showCount);\n      var count = shouldShowCount ? instance.localSearch.active ? instance.localSearch.countMap[node.id][instance.showCountOf] : node.count[instance.showCountOf] : NaN;\n      var labelClassName = "vue3-treeselect__label";\n      var countClassName = "vue3-treeselect__count";\n      var customLabelRenderer = instance.$slots["option-label"];\n      if (customLabelRenderer) {\n        return customLabelRenderer({\n          node: node,\n          shouldShowCount: shouldShowCount,\n          count: count,\n          labelClassName: labelClassName,\n          countClassName: countClassName\n        });\n      }\n      return (0,external_vue_namespaceObject.createVNode)("label", {\n        "class": labelClassName\n      }, [node.label, shouldShowCount && (0,external_vue_namespaceObject.createVNode)("span", {\n        "class": countClassName\n      }, [(0,external_vue_namespaceObject.createTextVNode)("("), count, (0,external_vue_namespaceObject.createTextVNode)(")")])]);\n    },\n    renderSubOptions: function renderSubOptions() {\n      var node = this.node;\n      if (!node.childrenStates.isLoaded) {\n        return null;\n      }\n      return node.children.map(function (childNode) {\n        return (0,external_vue_namespaceObject.createVNode)(Option, {\n          "node": childNode,\n          "key": childNode.id\n        }, null);\n      });\n    },\n    renderNoChildrenTip: function renderNoChildrenTip() {\n      var instance = this.instance,\n        node = this.node;\n      if (!node.childrenStates.isLoaded || node.children.length) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "no-children",\n        "icon": "warning"\n      }, {\n        default: function _default() {\n          return [instance.noChildrenText];\n        }\n      });\n    },\n    renderLoadingChildrenTip: function renderLoadingChildrenTip() {\n      var instance = this.instance,\n        node = this.node;\n      if (!node.childrenStates.isLoading) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "loading",\n        "icon": "loader"\n      }, {\n        default: function _default() {\n          return [instance.loadingText];\n        }\n      });\n    },\n    renderLoadingChildrenErrorTip: function renderLoadingChildrenErrorTip() {\n      var _this = this;\n      var instance = this.instance,\n        node = this.node;\n      if (!node.childrenStates.loadingError) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "error",\n        "icon": "error"\n      }, {\n        default: function _default() {\n          return [node.childrenStates.loadingError, (0,external_vue_namespaceObject.createVNode)("a", {\n            "class": "vue3-treeselect__retry",\n            "title": instance.retryTitle,\n            "onMousedown": _this.handleMouseDownOnRetry\n          }, [instance.retryText])];\n        }\n      });\n    },\n    handleMouseEnterOption: function handleMouseEnterOption(evt) {\n      var instance = this.instance,\n        node = this.node;\n\n      // Equivalent to `self` modifier.\n      // istanbul ignore next\n      if (evt.target !== evt.currentTarget) {\n        return;\n      }\n      instance.setCurrentHighlightedOption(node, false);\n    },\n    handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnOptionArrow() {\n      var instance = this.instance,\n        node = this.node;\n      instance.toggleExpanded(node);\n    }),\n    handleMouseDownOnLabelContainer: onLeftClick(function handleMouseDownOnLabelContainer() {\n      var instance = this.instance,\n        node = this.node;\n      if (node.isBranch && instance.disableBranchNodes) {\n        instance.toggleExpanded(node);\n      } else {\n        instance.select(node);\n      }\n    }),\n    handleMouseDownOnRetry: onLeftClick(function handleMouseDownOnRetry() {\n      var instance = this.instance,\n        node = this.node;\n      instance.loadChildrenOptions(node);\n    })\n  },\n  render: function render() {\n    var _slot;\n    var node = this.node;\n    var indentLevel = this.instance.shouldFlattenOptions ? 0 : node.level;\n    var listItemClass = Optionvue_type_script_lang_jsx_defineProperty({\n      "vue3-treeselect__list-item": true\n    }, "vue3-treeselect__indent-level-".concat(indentLevel), true);\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": listItemClass\n    }, [this.renderOption(), node.isBranch ? (0,external_vue_namespaceObject.createVNode)(Transition, {\n      "name": "vue3-treeselect__list--transition"\n    }, _isSlot(_slot = this.renderSubOptionsList()) ? _slot : {\n      default: function _default() {\n        return [_slot];\n      }\n    }) : ""]);\n  }\n};\n\n// eslint-disable-next-line vue/require-direct-export\n/* harmony default export */ var Optionvue_type_script_lang_jsx = (Option);\n;// CONCATENATED MODULE: ./src/components/Option.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Option.vue\n\n\n\n;\nconst Option_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Optionvue_type_script_lang_jsx, [[\'__file\',"src/components/Option.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var components_Option = (Option_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Menu.vue?vue&type=script&lang=jsx\n\n\n\n\n\nfunction Menuvue_type_script_lang_jsx_isSlot(s) {\n  return typeof s === \'function\' || Object.prototype.toString.call(s) === \'[object Object]\' && !(0,external_vue_namespaceObject.isVNode)(s);\n}\nvar directionMap = {\n  top: "top",\n  bottom: "bottom",\n  above: "top",\n  below: "bottom"\n};\n/* harmony default export */ var Menuvue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--menu",\n  inject: ["instance"],\n  computed: {\n    menuStyle: function menuStyle() {\n      var instance = this.instance;\n      return {\n        maxHeight: instance.maxHeight + "px"\n      };\n    },\n    menuContainerStyle: function menuContainerStyle() {\n      var instance = this.instance;\n      return {\n        zIndex: instance.appendToBody ? null : instance.zIndex\n      };\n    }\n  },\n  watch: {\n    "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {\n      if (newValue) {\n        // In case `openMenu()` is just called and the menu is not rendered yet.\n        this.$nextTick(this.onMenuOpen);\n      } else {\n        this.onMenuClose();\n      }\n    }\n  },\n  created: function created() {\n    this.menuSizeWatcher = null;\n    this.menuResizeAndScrollEventListeners = null;\n  },\n  mounted: function mounted() {\n    var instance = this.instance;\n    if (instance.menu.isOpen) {\n      this.$nextTick(this.onMenuOpen);\n    }\n  },\n  unmounted: function unmounted() {\n    this.onMenuClose();\n  },\n  methods: {\n    renderMenu: function renderMenu() {\n      var instance = this.instance;\n      if (!instance.menu.isOpen) {\n        return null;\n      }\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "ref": "menu",\n        "class": "vue3-treeselect__menu",\n        "onMousedown": instance.handleMouseDown,\n        "style": this.menuStyle,\n        "key": instance.menu.renderKey\n      }, [this.renderBeforeList(), instance.async ? this.renderAsyncSearchMenuInner() : instance.localSearch.active ? this.renderLocalSearchMenuInner() : this.renderNormalMenuInner(), this.renderAfterList()]);\n    },\n    renderBeforeList: function renderBeforeList() {\n      var instance = this.instance;\n      var beforeListRenderer = instance.$slots["before-list"];\n      return beforeListRenderer ? beforeListRenderer() : null;\n    },\n    renderAfterList: function renderAfterList() {\n      var instance = this.instance;\n      var afterListRenderer = instance.$slots["after-list"];\n      return afterListRenderer ? afterListRenderer() : null;\n    },\n    renderNormalMenuInner: function renderNormalMenuInner() {\n      var instance = this.instance;\n      if (instance.rootOptionsStates.isLoading) {\n        return this.renderLoadingOptionsTip();\n      } else if (instance.rootOptionsStates.loadingError) {\n        return this.renderLoadingRootOptionsErrorTip();\n      } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {\n        return this.renderNoAvailableOptionsTip();\n      } else {\n        return this.renderOptionList();\n      }\n    },\n    renderLocalSearchMenuInner: function renderLocalSearchMenuInner() {\n      var instance = this.instance;\n      if (instance.rootOptionsStates.isLoading) {\n        return this.renderLoadingOptionsTip();\n      } else if (instance.rootOptionsStates.loadingError) {\n        return this.renderLoadingRootOptionsErrorTip();\n      } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {\n        return this.renderNoAvailableOptionsTip();\n      } else if (instance.localSearch.noResults) {\n        return this.renderNoResultsTip();\n      } else {\n        return this.renderOptionList();\n      }\n    },\n    renderAsyncSearchMenuInner: function renderAsyncSearchMenuInner() {\n      var instance = this.instance;\n      var entry = instance.getRemoteSearchEntry();\n      var shouldShowSearchPromptTip = instance.trigger.searchQuery === "" && !instance.options;\n      var shouldShowNoResultsTip = shouldShowSearchPromptTip ? false : entry.isLoaded && entry.options.length === 0;\n      if (shouldShowSearchPromptTip) {\n        return this.renderSearchPromptTip();\n      } else if (entry.isLoading) {\n        return this.renderLoadingOptionsTip();\n      } else if (entry.loadingError) {\n        return this.renderAsyncSearchLoadingErrorTip();\n      } else if (shouldShowNoResultsTip) {\n        return this.renderNoResultsTip();\n      } else {\n        return this.renderOptionList();\n      }\n    },\n    renderOptionList: function renderOptionList() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__list"\n      }, [instance.forest.normalizedOptions.map(function (rootNode) {\n        return (0,external_vue_namespaceObject.createVNode)(components_Option, {\n          "node": rootNode,\n          "key": rootNode.id\n        }, null);\n      })]);\n    },\n    renderSearchPromptTip: function renderSearchPromptTip() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "search-prompt",\n        "icon": "warning"\n      }, {\n        default: function _default() {\n          return [instance.searchPromptText];\n        }\n      });\n    },\n    renderLoadingOptionsTip: function renderLoadingOptionsTip() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "loading",\n        "icon": "loader"\n      }, {\n        default: function _default() {\n          return [instance.loadingText];\n        }\n      });\n    },\n    renderLoadingRootOptionsErrorTip: function renderLoadingRootOptionsErrorTip() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "error",\n        "icon": "error"\n      }, {\n        default: function _default() {\n          return [instance.rootOptionsStates.loadingError, (0,external_vue_namespaceObject.createVNode)("a", {\n            "class": "vue3-treeselect__retry",\n            "onClick": instance.loadRootOptions,\n            "title": instance.retryTitle\n          }, [instance.retryText])];\n        }\n      });\n    },\n    renderAsyncSearchLoadingErrorTip: function renderAsyncSearchLoadingErrorTip() {\n      var instance = this.instance;\n      var entry = instance.getRemoteSearchEntry();\n\n      // TODO: retryTitle?\n\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "error",\n        "icon": "error"\n      }, {\n        default: function _default() {\n          return [entry.loadingError, (0,external_vue_namespaceObject.createVNode)("a", {\n            "class": "vue3-treeselect__retry",\n            "onClick": instance.handleRemoteSearch,\n            "title": instance.retryTitle\n          }, [instance.retryText])];\n        }\n      });\n    },\n    renderNoAvailableOptionsTip: function renderNoAvailableOptionsTip() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "no-options",\n        "icon": "warning"\n      }, {\n        default: function _default() {\n          return [instance.noOptionsText];\n        }\n      });\n    },\n    renderNoResultsTip: function renderNoResultsTip() {\n      var instance = this.instance;\n      return (0,external_vue_namespaceObject.createVNode)(Tip, {\n        "type": "no-results",\n        "icon": "warning"\n      }, {\n        default: function _default() {\n          return [instance.noResultsText];\n        }\n      });\n    },\n    onMenuOpen: function onMenuOpen() {\n      this.adjustMenuOpenDirection();\n      this.setupMenuSizeWatcher();\n      this.setupMenuResizeAndScrollEventListeners();\n    },\n    onMenuClose: function onMenuClose() {\n      this.removeMenuSizeWatcher();\n      this.removeMenuResizeAndScrollEventListeners();\n    },\n    adjustMenuOpenDirection: function adjustMenuOpenDirection() {\n      var instance = this.instance;\n      if (!instance.menu.isOpen) {\n        return;\n      }\n      var $menu = instance.getMenu();\n      var $control = instance.getControl();\n      var menuRect = $menu.getBoundingClientRect();\n      var controlRect = $control.getBoundingClientRect();\n      var menuHeight = menuRect.height;\n      var viewportHeight = window.innerHeight;\n      var spaceAbove = controlRect.top;\n      var spaceBelow = window.innerHeight - controlRect.bottom;\n      var isControlInViewport = controlRect.top >= 0 && controlRect.top <= viewportHeight || controlRect.top < 0 && controlRect.bottom > 0;\n      var hasEnoughSpaceBelow = spaceBelow > menuHeight + MENU_BUFFER;\n      var hasEnoughSpaceAbove = spaceAbove > menuHeight + MENU_BUFFER;\n      if (!isControlInViewport) {\n        instance.closeMenu();\n      } else if (instance.openDirection !== "auto") {\n        instance.menu.placement = directionMap[instance.openDirection];\n      } else if (hasEnoughSpaceBelow || !hasEnoughSpaceAbove) {\n        instance.menu.placement = "bottom";\n      } else {\n        instance.menu.placement = "top";\n      }\n    },\n    setupMenuSizeWatcher: function setupMenuSizeWatcher() {\n      var instance = this.instance;\n      var $menu = instance.getMenu();\n\n      // istanbul ignore next\n      if (this.menuSizeWatcher) {\n        return;\n      }\n      this.menuSizeWatcher = {\n        remove: watchSize($menu, this.adjustMenuOpenDirection)\n      };\n    },\n    setupMenuResizeAndScrollEventListeners: function setupMenuResizeAndScrollEventListeners() {\n      var instance = this.instance;\n      var $control = instance.getControl();\n\n      // istanbul ignore next\n      if (this.menuResizeAndScrollEventListeners) {\n        return;\n      }\n      this.menuResizeAndScrollEventListeners = {\n        remove: setupResizeAndScrollEventListeners($control, this.adjustMenuOpenDirection)\n      };\n    },\n    removeMenuSizeWatcher: function removeMenuSizeWatcher() {\n      if (!this.menuSizeWatcher) {\n        return;\n      }\n      this.menuSizeWatcher.remove();\n      this.menuSizeWatcher = null;\n    },\n    removeMenuResizeAndScrollEventListeners: function removeMenuResizeAndScrollEventListeners() {\n      if (!this.menuResizeAndScrollEventListeners) {\n        return;\n      }\n      this.menuResizeAndScrollEventListeners.remove();\n      this.menuResizeAndScrollEventListeners = null;\n    }\n  },\n  render: function render() {\n    var _slot;\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "ref": "menu-container",\n      "class": "vue3-treeselect__menu-container",\n      "style": this.menuContainerStyle\n    }, [(0,external_vue_namespaceObject.createVNode)(Transition, {\n      "name": "vue3-treeselect__menu--transition"\n    }, Menuvue_type_script_lang_jsx_isSlot(_slot = this.renderMenu()) ? _slot : {\n      default: function _default() {\n        return [_slot];\n      }\n    })]);\n  }\n});\n;// CONCATENATED MODULE: ./src/components/Menu.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Menu.vue\n\n\n\n;\nconst Menu_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Menuvue_type_script_lang_jsx, [[\'__file\',"src/components/Menu.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Menu = (Menu_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/MenuPortal.vue?vue&type=script&lang=jsx\n\nfunction MenuPortalvue_type_script_lang_jsx_typeof(o) { "@babel/helpers - typeof"; return MenuPortalvue_type_script_lang_jsx_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, MenuPortalvue_type_script_lang_jsx_typeof(o); }\nfunction MenuPortalvue_type_script_lang_jsx_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction MenuPortalvue_type_script_lang_jsx_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? MenuPortalvue_type_script_lang_jsx_ownKeys(Object(t), !0).forEach(function (r) { MenuPortalvue_type_script_lang_jsx_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : MenuPortalvue_type_script_lang_jsx_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction MenuPortalvue_type_script_lang_jsx_defineProperty(obj, key, value) { key = MenuPortalvue_type_script_lang_jsx_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction MenuPortalvue_type_script_lang_jsx_toPropertyKey(arg) { var key = MenuPortalvue_type_script_lang_jsx_toPrimitive(arg, "string"); return MenuPortalvue_type_script_lang_jsx_typeof(key) === "symbol" ? key : String(key); }\nfunction MenuPortalvue_type_script_lang_jsx_toPrimitive(input, hint) { if (MenuPortalvue_type_script_lang_jsx_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (MenuPortalvue_type_script_lang_jsx_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar PortalTarget = {\n  name: "vue3-treeselect--portal-target",\n  inject: ["instance"],\n  watch: {\n    "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {\n      if (newValue) {\n        this.setupHandlers();\n      } else {\n        this.removeHandlers();\n      }\n    },\n    "instance.menu.placement": function instanceMenuPlacement() {\n      this.updateMenuContainerOffset();\n    }\n  },\n  created: function created() {\n    this.controlResizeAndScrollEventListeners = null;\n    this.controlSizeWatcher = null;\n  },\n  mounted: function mounted() {\n    var instance = this.instance;\n    if (instance.menu.isOpen) {\n      this.setupHandlers();\n    }\n  },\n  methods: {\n    setupHandlers: function setupHandlers() {\n      this.updateWidth();\n      this.updateMenuContainerOffset();\n      this.setupControlResizeAndScrollEventListeners();\n      this.setupControlSizeWatcher();\n    },\n    removeHandlers: function removeHandlers() {\n      this.removeControlResizeAndScrollEventListeners();\n      this.removeControlSizeWatcher();\n    },\n    setupControlResizeAndScrollEventListeners: function setupControlResizeAndScrollEventListeners() {\n      var instance = this.instance;\n      var $control = instance.getControl();\n\n      // istanbul ignore next\n      if (this.controlResizeAndScrollEventListeners) {\n        return;\n      }\n      this.controlResizeAndScrollEventListeners = {\n        remove: setupResizeAndScrollEventListeners($control, this.updateMenuContainerOffset)\n      };\n    },\n    setupControlSizeWatcher: function setupControlSizeWatcher() {\n      var _this = this;\n      var instance = this.instance;\n      var $control = instance.getControl();\n\n      // istanbul ignore next\n      if (this.controlSizeWatcher) {\n        return;\n      }\n      this.controlSizeWatcher = {\n        remove: watchSize($control, function () {\n          _this.updateWidth();\n          _this.updateMenuContainerOffset();\n        })\n      };\n    },\n    removeControlResizeAndScrollEventListeners: function removeControlResizeAndScrollEventListeners() {\n      if (!this.controlResizeAndScrollEventListeners) {\n        return;\n      }\n      this.controlResizeAndScrollEventListeners.remove();\n      this.controlResizeAndScrollEventListeners = null;\n    },\n    removeControlSizeWatcher: function removeControlSizeWatcher() {\n      if (!this.controlSizeWatcher) {\n        return;\n      }\n      this.controlSizeWatcher.remove();\n      this.controlSizeWatcher = null;\n    },\n    updateWidth: function updateWidth() {\n      var instance = this.instance;\n      var $portalTarget = this.$el;\n      var $control = instance.getControl();\n      var controlRect = $control.getBoundingClientRect();\n      $portalTarget.style.width = controlRect.width + "px";\n    },\n    updateMenuContainerOffset: function updateMenuContainerOffset() {\n      var instance = this.instance;\n      var $control = instance.getControl();\n      var $portalTarget = this.$el;\n      var controlRect = $control.getBoundingClientRect();\n      var portalTargetRect = $portalTarget.getBoundingClientRect();\n      var offsetY = instance.menu.placement === "bottom" ? controlRect.height : 0;\n      var left = Math.round(controlRect.left - portalTargetRect.left) + "px";\n      var top = Math.round(controlRect.top - portalTargetRect.top + offsetY) + "px";\n      var menuContainerStyle = this.$refs.menu.$refs["menu-container"].style;\n      var transformVariations = ["transform", "webkitTransform", "MozTransform", "msTransform"];\n      var transform = find(transformVariations, function (t) {\n        return t in document.body.style;\n      });\n\n      // IE9 doesn\'t support `translate3d()`.\n      menuContainerStyle[transform] = "translate(".concat(left, ", ").concat(top, ")");\n    }\n  },\n  render: function render() {\n    var instance = this.instance;\n    var portalTargetClass = ["vue3-treeselect__portal-target", instance.wrapperClass];\n    var portalTargetStyle = {\n      zIndex: instance.zIndex\n    };\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": portalTargetClass,\n      "style": portalTargetStyle,\n      "data-instance-id": instance.getInstanceId()\n    }, [(0,external_vue_namespaceObject.createVNode)(Menu, {\n      "ref": "menu"\n    }, null)]);\n  },\n  unmounted: function unmounted() {\n    this.removeHandlers();\n  }\n};\nvar placeholder;\n/* harmony default export */ var MenuPortalvue_type_script_lang_jsx = ({\n  name: "vue3-treeselect--menu-portal",\n  created: function created() {\n    this.portalTarget = null;\n  },\n  mounted: function mounted() {\n    this.setup();\n  },\n  unmounted: function unmounted() {\n    this.teardown();\n  },\n  methods: {\n    setup: function setup() {\n      var el = document.createElement("div");\n      document.body.appendChild(el);\n      this.portalTarget = createApp(MenuPortalvue_type_script_lang_jsx_objectSpread({\n        parent: this\n      }, PortalTarget));\n      this.portalTarget.mount(el);\n      // this.portalTarget = new Vue({\n      //   el,\n      //   parent: this,\n      //   ...PortalTarget,\n      // })\n    },\n    teardown: function teardown() {\n      document.body.removeChild(this.portalTarget.$el);\n      this.portalTarget.$el.innerHTML = "";\n      this.portalTarget.$destroy();\n      this.portalTarget = null;\n    }\n  },\n  render: function render() {\n    if (!placeholder) {\n      placeholder = (0,external_vue_namespaceObject.createVNode)("div", {\n        "class": "vue3-treeselect__menu-placeholder"\n      }, null);\n    }\n    return placeholder;\n  }\n});\n;// CONCATENATED MODULE: ./src/components/MenuPortal.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/MenuPortal.vue\n\n\n\n;\nconst MenuPortal_exports_ = /*#__PURE__*/(0,exportHelper["default"])(MenuPortalvue_type_script_lang_jsx, [[\'__file\',"src/components/MenuPortal.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var MenuPortal = (MenuPortal_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/components/Treeselect.vue?vue&type=script&lang=jsx\n\n\n\n\n\n\n\n/* harmony default export */ var Treeselectvue_type_script_lang_jsx = ((0,external_vue_namespaceObject.defineComponent)({\n  name: "vue3-treeselect",\n  components: {\n    HiddenFields: HiddenFields,\n    Control: Control,\n    TreeMenu: Menu,\n    MenuPortal: MenuPortal\n  },\n  mixins: [treeselectMixin],\n  computed: {\n    wrapperClass: function wrapperClass() {\n      return {\n        "vue3-treeselect": true,\n        "vue3-treeselect--single": this.single,\n        "vue3-treeselect--multi": this.multiple,\n        "vue3-treeselect--searchable": this.searchable,\n        "vue3-treeselect--disabled": this.disabled,\n        "vue3-treeselect--focused": this.trigger.isFocused,\n        "vue3-treeselect--has-value": this.hasValue,\n        "vue3-treeselect--open": this.menu.isOpen,\n        "vue3-treeselect--open-above": this.menu.placement === "top",\n        "vue3-treeselect--open-below": this.menu.placement === "bottom",\n        "vue3-treeselect--branch-nodes-disabled": this.disableBranchNodes,\n        "vue3-treeselect--append-to-body": this.appendToBody\n      };\n    }\n  },\n  methods: {\n    handlePageClick: function handlePageClick(page) {\n      this.$emit(\'page-click\', page);\n    }\n  },\n  render: function render() {\n    return (0,external_vue_namespaceObject.createVNode)("div", {\n      "ref": "wrapper",\n      "class": this.wrapperClass\n    }, [(0,external_vue_namespaceObject.createVNode)(HiddenFields, null, null), (0,external_vue_namespaceObject.createVNode)(Control, {\n      "ref": "control"\n    }, null), this.appendToBody ? (0,external_vue_namespaceObject.createVNode)(MenuPortal, {\n      "ref": "portal"\n    }, null) : (0,external_vue_namespaceObject.createVNode)(Menu, {\n      "ref": "menu"\n    }, null), (0,external_vue_namespaceObject.createVNode)("div", {\n      "class": "pagination"\n    }, [this.$slots.pagination ? this.$slots.pagination({\n      handlePageClick: this.handlePageClick\n    }) : null])]);\n  }\n}));\n;// CONCATENATED MODULE: ./src/components/Treeselect.vue?vue&type=script&lang=jsx\n \n;// CONCATENATED MODULE: ./src/components/Treeselect.vue\n\n\n\n;\nconst Treeselect_exports_ = /*#__PURE__*/(0,exportHelper["default"])(Treeselectvue_type_script_lang_jsx, [[\'__file\',"src/components/Treeselect.vue"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ var Treeselect = (Treeselect_exports_);\n;// CONCATENATED MODULE: ./styles/style.less\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n/* harmony default export */ var src = (Treeselect);\n\n\nvar VERSION = "0.1.4";\n\n//# sourceURL=webpack://@chege-simon/vue3-treeselect/./src/index.js_+_79_modules?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=function(e,n){for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},__webpack_require__.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__}()}));